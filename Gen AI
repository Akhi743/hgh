import os
import csv
import re
from datetime import datetime
from PyPDF2 import PdfReader
from concurrent.futures import ThreadPoolExecutor, as_completed
from langchain.chat_models import ChatOpenAI
from langchain.schema import SystemMessage, HumanMessage

# ðŸ”‘ Your OpenAI API key
openai_key = "sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"

llm = ChatOpenAI(model="gpt-4", temperature=0, openai_api_key=openai_key)

VALID_STATES = [
    "ILLINOIS", "INDIANA", "IOWA", "KANSAS", "KENTUCKY", "MICHIGAN", "MISSOURI",
    "NEBRASKA", "NORTH DAKOTA", "OHIO", "OKLAHOMA", "SOUTH DAKOTA", "WISCONSIN"
]

REQUIRED_FIELDS = [
    "Facility", "Charge Master Limit", "Charge Master Increase",
    "Rate Adjustment Date", "Business", "Service Category",
    "Current Rate", "Adjusted New Rate"
]

def extract_text(pdf_path):
    try:
        reader = PdfReader(pdf_path)
        return "\n".join(page.extract_text() or "" for page in reader.pages)
    except:
        return ""

def extract_relevant_sections(text, keywords):
    lines = text.splitlines()
    relevant = [line.strip() for line in lines if any(k.lower() in line.lower() for k in keywords)]
    return "\n".join(relevant)

def extract_effective_date(text):
    relevant_text = extract_relevant_sections(text, ["Rate Adjustment Date", "Effective Date"])
    if not relevant_text.strip():
        return None

    prompt = [
        SystemMessage(content="You are an expert in hospital contract analysis."),
        HumanMessage(content=f"""
Extract the latest date value found from either 'Rate Adjustment Date' or 'Effective Date'.
Return JSON in this format:
{{ "date": "MM/DD/YYYY" }} if a date is found,
or {{ "date": null }} if no date found.

Text:
{relevant_text}
""")
    ]
    try:
        response = llm(prompt).content.strip()
        match = re.search(r'"date":\s*"(\d{2}/\d{2}/\d{4})"', response)
        if not match:
            return None
        return datetime.strptime(match.group(1), "%m/%d/%Y")
    except:
        return None

def check_required_fields(text):
    relevant_text = extract_relevant_sections(text, REQUIRED_FIELDS)
    if not relevant_text.strip():
        return False

    prompt = [
        SystemMessage(content="You are an expert in hospital contract analysis."),
        HumanMessage(content=f"""
Check if ALL the following fields are mentioned in the text below:
- Facility
- Charge Master Limit
- Charge Master Increase
- Rate Adjustment Date
- Business
- Service Category
- Current Rate
- Adjusted New Rate

Respond ONLY with JSON: {{ "valid": true }} or {{ "valid": false }}

Text:
{relevant_text}
""")
    ]
    try:
        response = llm(prompt).content.strip()
        return '"valid": true' in response.lower()
    except:
        return False

def is_valid_contract(text):
    date = extract_effective_date(text)
    if not date or date <= datetime(2024, 7, 1):
        return False
    return check_required_fields(text)

def get_state_folders(base):
    return [
        os.path.join(base, d) for d in os.listdir(base)
        if os.path.isdir(os.path.join(base, d)) and any(state in d.upper() for state in VALID_STATES)
    ]

def find_pdfs(folder):
    pdfs = []
    for root, _, files in os.walk(folder):
        if "hospitals" in root.lower():
            for f in files:
                if f.lower().endswith(".pdf"):
                    pdfs.append(os.path.join(root, f))
    return pdfs

def classify_single(pdf_path):
    text = extract_text(pdf_path)
    return (pdf_path, is_valid_contract(text))

def classify_pdfs_parallel(base, max_workers=4):
    pdf_paths = []
    for folder in get_state_folders(base):
        pdf_paths.extend(find_pdfs(folder))

    valid, skipped = [], []
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        futures = {executor.submit(classify_single, pdf): pdf for pdf in pdf_paths}
        for future in as_completed(futures):
            pdf_path, is_valid = future.result()
            (valid if is_valid else skipped).append(pdf_path)
    return valid, skipped

def save_csv(valid, skipped, out_dir="classification_results"):
    os.makedirs(out_dir, exist_ok=True)
    with open(os.path.join(out_dir, "valid_contracts.csv"), "w", newline='', encoding="utf-8") as f:
        csv.writer(f).writerows([["Valid PDF Files"]] + [[v] for v in valid])
    with open(os.path.join(out_dir, "skipped_contracts.csv"), "w", newline='', encoding="utf-8") as f:
        csv.writer(f).writerows([["Skipped PDF Files"]] + [[s] for s in skipped])

if __name__ == "__main__":
    base_path = "./midamreprc/AGREEMENTS-NON STANDARD"
    valid, skipped = classify_pdfs_parallel(base_path, max_workers=4)
    save_csv(valid, skipped)
