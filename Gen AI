# 0) Install dependencies (run once)
# pip install easyocr pdf2image openai instructor pandas openpyxl

import instructor
from pydantic import BaseModel, Field
from typing import List, Optional
import json
from pprint import pprint
from tenacity import Retrying, retry_if_not_exception_type, stop_after_attempt
from pydantic import AfterValidator, field_validator, model_validator
from instructor.exceptions import InstructorRetryException
import re
# import ocrutils  # Commented out since module not found
# import form_model as model  # Commented out if not needed
from openai import OpenAI
import pandas as pd
import os

# === CONFIGURATION ===
PDF_PATH = r"C:\path\to\your_contract.pdf"          # ← your PDF file
OUTPUT_XLSX = r"C:\path\to\contract_rates.xlsx"     # ← where to save Excel
MODEL_NAME = "openai/gpt-4o-mini"                   # ← your model or Azure deployment
os.environ["OPENAI_API_KEY"] = "sk-..."             # ← your OpenAI or Azure token

# === 1) Initialize the Instructor client ===
CLIENT = None
def init_model():
    global CLIENT
    CLIENT = instructor.from_openai(
        OpenAI(api_key=os.environ["OPENAI_API_KEY"]),
        mode=instructor.Mode.JSON
    )
init_model()

# === 2) Get OCR text ===
# Using EasyOCR for actual OCR on scanned PDFs
try:
    import easyocr
    from pdf2image import convert_from_path
    import numpy as np
    
    # Initialize EasyOCR reader
    print("Initializing EasyOCR...")
    reader = easyocr.Reader(['en'], gpu=False)  # Set gpu=True if you have CUDA
    
    # Convert PDF to images
    print(f"Converting PDF to images: {PDF_PATH}")
    images = convert_from_path(PDF_PATH, dpi=300)
    
    ocr_text = ""
    for i, image in enumerate(images):
        print(f"Processing page {i+1}/{len(images)}...")
        
        # Convert PIL image to numpy array
        img_array = np.array(image)
        
        # Perform OCR
        result = reader.readtext(img_array, detail=0)  # detail=0 returns only text
        page_text = ' '.join(result)
        ocr_text += page_text + "\n"
    
    # Create info object to match expected structure
    class Info:
        def __init__(self, text):
            self.context = {"ocr_text": text}
    
    info = Info(ocr_text)
    
except ImportError as e:
    print("Required packages not installed. Please install:")
    print("pip install easyocr pdf2image pillow")
    print(f"Error: {e}")
    raise

if not ocr_text:
    raise RuntimeError("No OCR text found in info.context")
if not ocr_text:
    raise RuntimeError("No OCR text found in info.context")
print(f"\n✅ Total OCR text chars: {len(ocr_text)}\n")
print(f"Processing PDF: {PDF_PATH}")

# === 3) Define Pydantic schema with validators & N/A fallback ===
class HospitalRateEntry(BaseModel):
    hospital: str = Field(..., description="Facility name")
    lob: str = Field(..., description="Line of business")
    place_of_service: str = Field(..., description="IP or OP")
    service_category: str
    billing_code_type: str
    billing_code: str
    rate: str
    negotiated_type: str
    additional_information: Optional[str] = ""
    effective_date: str

    @field_validator("rate")
    def check_rate(cls, v):
        if not re.match(r"^\$?\d{1,3}(,\d{3})*(\.\d{2})?$|^\d{1,3}%$", v.strip()):
            raise ValueError(f"Invalid rate: {v}")
        return v.strip()

    @field_validator("billing_code")
    def check_code(cls, v):
        if not re.match(r"^[A-Za-z0-9\-, ]+$", v.strip()):
            raise ValueError(f"Invalid code: {v}")
        return v.strip()

    @model_validator(mode="after")
    def fill_na(self):
        for field_name in self.model_fields:
            val = getattr(self, field_name)
            if not val or (isinstance(val, str) and not val.strip()):
                setattr(self, field_name, "N/A")
        return self

# === 4) Extract entries with retry logic ===
prompt = f"""
Extract every billing entry from this hospital contract into a JSON array.
Each object must have exactly these keys:
hospital, lob, place_of_service, service_category,
billing_code_type, billing_code, rate, negotiated_type,
additional_information, effective_date

Here is the contract text:
\"\"\"
{ocr_text}
\"\"\"
"""

# Use tenacity retry logic
entries = []
for attempt in Retrying(
    retry=retry_if_not_exception_type(InstructorRetryException),
    stop=stop_after_attempt(3)
):
    with attempt:
        try:
            res = CLIENT.chat.completions.create(
                model=MODEL_NAME,
                messages=[
                    {"role": "system", "content": "You extract structured JSON only."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0,
                response_model=List[HospitalRateEntry]  # Direct validation
            )
            entries = res
        except Exception as e:
            print(f"Attempt {attempt.retry_state.attempt_number} failed: {e}")
            if attempt.retry_state.attempt_number == 3:
                raise

print("— Raw extracted entries —")
for i, e in enumerate(entries, 1):
    print(f"{i:2d}.", e.model_dump())

# === 5) Expand billing-code ranges (e.g. "190-192") ===
def expand_codes(entry: HospitalRateEntry) -> List[HospitalRateEntry]:
    expanded = []
    for part in re.split(r',\s*', entry.billing_code):
        if '-' in part:
            nums = re.findall(r'\d+', part)
            if len(nums) >= 2:
                start, end = int(nums[0]), int(nums[1])
                for n in range(start, end + 1):
                    new_entry = entry.model_copy()
                    new_entry.billing_code = str(n)
                    expanded.append(new_entry)
            else:
                new_entry = entry.model_copy()
                new_entry.billing_code = part.strip()
                expanded.append(new_entry)
        else:
            new_entry = entry.model_copy()
            new_entry.billing_code = part.strip()
            expanded.append(new_entry)
    return expanded

final_entries: List[HospitalRateEntry] = []
print("\n— Range expansions —")
for entry in entries:
    expanded = expand_codes(entry)
    print(f" {entry.billing_code} → {[x.billing_code for x in expanded]}")
    final_entries.extend(expanded)

# === 6) Convert to DataFrame and export to Excel ===
df = pd.DataFrame([entry.model_dump() for entry in final_entries])

# Reorder columns
columns = [
    "hospital", "lob", "place_of_service", "service_category",
    "billing_code_type", "billing_code", "rate", "negotiated_type",
    "additional_information", "effective_date"
]
df = df[columns].fillna("N/A")

# Export to Excel
df.to_excel(OUTPUT_XLSX, index=False)

print(f"\n✅ Wrote {len(df)} rows to {OUTPUT_XLSX}")
pprint(df.head().to_dict('records'))
