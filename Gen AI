import instructor
from pydantic import BaseModel, Field
from typing import List, Optional
import json
from pprint import pprint
from tenacity import Retrying, retry_if_not_exception_type, stop_after_attempt
from pydantic import AfterValidator, field_validator, model_validator
from instructor.exceptions import InstructorRetryException
import re
import ocrutils
import form_model as model
from openai import OpenAI
import pandas as pd
import os

# === CONFIGURATION ===
PDF_PATH = r"C:\path\to\your_contract.pdf"          # ← your PDF file
OUTPUT_XLSX = r"C:\path\to\contract_rates.xlsx"     # ← where to save Excel
MODEL_NAME = "openai/gpt-4o-mini"                   # ← your model or Azure deployment
os.environ["OPENAI_API_KEY"] = "sk-..."             # ← your OpenAI or Azure token

# === 1) Initialize the Instructor client ===
CLIENT = None
def init_model():
    global CLIENT
    CLIENT = instructor.from_openai(
        OpenAI(api_key=os.environ["OPENAI_API_KEY"]),
        mode=instructor.Mode.JSON
    )
init_model()

# === 2) Get OCR text using ocrutils ===
# Use ocrutils to process the PDF and get OCR text
info = ocrutils.process_pdf(PDF_PATH)  # Assuming ocrutils has a process_pdf function
ocr_text = info.context["ocr_text"]

if not ocr_text:
    raise RuntimeError("No OCR text found in info.context")
if not ocr_text:
    raise RuntimeError("No OCR text found in info.context")
print(f"\n✅ Total OCR text chars: {len(ocr_text)}\n")
print(f"Processing PDF: {PDF_PATH}")

# === 3) Define Pydantic schema with validators & N/A fallback ===
class HospitalRateEntry(BaseModel):
    hospital: str = Field(..., description="Facility name")
    lob: str = Field(..., description="Line of business")
    place_of_service: str = Field(..., description="IP or OP")
    service_category: str
    billing_code_type: str
    billing_code: str
    rate: str
    negotiated_type: str
    additional_information: Optional[str] = ""
    effective_date: str

    @field_validator("rate")
    def check_rate(cls, v):
        if not re.match(r"^\$?\d{1,3}(,\d{3})*(\.\d{2})?$|^\d{1,3}%$", v.strip()):
            raise ValueError(f"Invalid rate: {v}")
        return v.strip()

    @field_validator("billing_code")
    def check_code(cls, v):
        if not re.match(r"^[A-Za-z0-9\-, ]+$", v.strip()):
            raise ValueError(f"Invalid code: {v}")
        return v.strip()

    @model_validator(mode="after")
    def fill_na(self):
        for field_name in self.model_fields:
            val = getattr(self, field_name)
            if not val or (isinstance(val, str) and not val.strip()):
                setattr(self, field_name, "N/A")
        return self

# === 4) Extract entries with retry logic ===
prompt = f"""
Extract every billing entry from this hospital contract into a JSON array.
Each object must have exactly these keys:
hospital, lob, place_of_service, service_category,
billing_code_type, billing_code, rate, negotiated_type,
additional_information, effective_date

Here is the contract text:
\"\"\"
{ocr_text}
\"\"\"
"""

# Use tenacity retry logic
entries = []
for attempt in Retrying(
    retry=retry_if_not_exception_type(InstructorRetryException),
    stop=stop_after_attempt(3)
):
    with attempt:
        try:
            res = CLIENT.chat.completions.create(
                model=MODEL_NAME,
                messages=[
                    {"role": "system", "content": "You extract structured JSON only."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0,
                response_model=List[HospitalRateEntry]  # Direct validation
            )
            entries = res
        except Exception as e:
            print(f"Attempt {attempt.retry_state.attempt_number} failed: {e}")
            if attempt.retry_state.attempt_number == 3:
                raise

print("— Raw extracted entries —")
for i, e in enumerate(entries, 1):
    print(f"{i:2d}.", e.model_dump())

# === 5) Expand billing-code ranges (e.g. "190-192") ===
def expand_codes(entry: HospitalRateEntry) -> List[HospitalRateEntry]:
    expanded = []
    for part in re.split(r',\s*', entry.billing_code):
        if '-' in part:
            nums = re.findall(r'\d+', part)
            if len(nums) >= 2:
                start, end = int(nums[0]), int(nums[1])
                for n in range(start, end + 1):
                    new_entry = entry.model_copy()
                    new_entry.billing_code = str(n)
                    expanded.append(new_entry)
            else:
                new_entry = entry.model_copy()
                new_entry.billing_code = part.strip()
                expanded.append(new_entry)
        else:
            new_entry = entry.model_copy()
            new_entry.billing_code = part.strip()
            expanded.append(new_entry)
    return expanded

final_entries: List[HospitalRateEntry] = []
print("\n— Range expansions —")
for entry in entries:
    expanded = expand_codes(entry)
    print(f" {entry.billing_code} → {[x.billing_code for x in expanded]}")
    final_entries.extend(expanded)

# === 6) Convert to DataFrame and export to Excel ===
df = pd.DataFrame([entry.model_dump() for entry in final_entries])

# Reorder columns
columns = [
    "hospital", "lob", "place_of_service", "service_category",
    "billing_code_type", "billing_code", "rate", "negotiated_type",
    "additional_information", "effective_date"
]
df = df[columns].fillna("N/A")

# Export to Excel
df.to_excel(OUTPUT_XLSX, index=False)

print(f"\n✅ Wrote {len(df)} rows to {OUTPUT_XLSX}")
pprint(df.head().to_dict('records'))
