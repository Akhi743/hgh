# Install any missing packages (run once)
!pip install PyPDF2 contextgem PyMuPDF pytesseract pdf2image pandas openpyxl

# === Imports ===
import os, re
import pandas as pd
from pydantic import BaseModel, Field, field_validator, model_validator
from typing import Optional

# PDF text extractors
from PyPDF2 import PdfReader
import fitz                       # PyMuPDF
import pytesseract
from pdf2image import convert_from_path
from PIL import Image

# ContextGem
from contextgem import Document, DocumentLLM, JsonObjectConcept

# === CONFIG ===
PDF_PATH     = r"C:\path\to\your_contract.pdf"      # ← your PDF
OUTPUT_XLSX  = r"C:\path\to\contract_rates.xlsx"    # ← output file
MODEL_NAME   = "openai/gpt-4o-mini"                 # or your Azure deployment
os.environ["CONTEXTGEM_OPENAI_API_KEY"] = "sk-..."  # ← your key

# === STEP 1: Try PyPDF2 ===
pages = []
reader = PdfReader(PDF_PATH)
for i, page in enumerate(reader.pages, 1):
    txt = page.extract_text() or ""
    print(f"[PyPDF2] Page {i} length: {len(txt)}")
    pages.append(txt)

contract_text = "\n".join(pages).strip()

# === STEP 2: Fallback to PyMuPDF if empty ===
if not contract_text:
    print("\nPyPDF2 failed; trying PyMuPDF...")
    pages = []
    doc = fitz.open(PDF_PATH)
    for i, p in enumerate(doc, 1):
        txt = p.get_text("text") or ""
        print(f"[PyMuPDF] Page {i} length: {len(txt)}")
        pages.append(txt)
    contract_text = "\n".join(pages).strip()

# === STEP 3: Fallback to OCR if still empty ===
if not contract_text:
    print("\nPyMuPDF failed; falling back to Tesseract OCR...")
    pages = []
    images = convert_from_path(PDF_PATH, dpi=200)
    for i, img in enumerate(images, 1):
        txt = pytesseract.image_to_string(img)
        print(f"[OCR] Page {i} length: {len(txt)}")
        pages.append(txt)
    contract_text = "\n".join(pages).strip()

if not contract_text:
    raise RuntimeError("All extraction methods failed—no text found in PDF.")

print(f"\n✅ Extracted {len(contract_text)} total characters. Proceeding…")

# === STEP 4: Define Pydantic schema with validators ===
class HospitalRateEntry(BaseModel):
    hospital: str = Field(..., description="Facility name")
    lob: str = Field(..., description="Line of business")
    place_of_service: str = Field(..., description="IP or OP")
    service_category: str
    billing_code_type: str
    billing_code: str
    rate: str
    negotiated_type: str
    additional_information: Optional[str] = ""
    effective_date: str

    @field_validator("rate")
    def _check_rate(cls, v):
        v = v.strip()
        if not re.match(r"^\$?\d{1,3}(,\d{3})*(\.\d{2})?$|^\d{1,3}%$", v):
            raise ValueError(f"Bad rate format: {v}")
        return v

    @field_validator("billing_code")
    def _check_code(cls, v):
        v = v.strip()
        if not re.match(r"^[A-Za-z0-9\-, ]+$", v):
            raise ValueError(f"Bad billing code: {v}")
        return v

    @model_validator(mode="after")
    def _fill_na(self):
        for f in self.__fields__:
            val = getattr(self, f)
            if val is None or (isinstance(val, str) and not val.strip()):
                setattr(self, f, "N/A")
        return self

# === STEP 5: Build ContextGem Document & extract ===
doc = Document(raw_text=contract_text)
doc.add_concepts([ JsonObjectConcept(
    name="HospitalRateEntry",
    description="Extract one billing code per row with context & rates",
    schema=HospitalRateEntry,
    many=True
)])

llm = DocumentLLM(model=MODEL_NAME, api_key=os.environ["CONTEXTGEM_OPENAI_API_KEY"])
doc = llm.extract_all(doc)
entries = doc.get_concept_by_name("HospitalRateEntry").extracted_items

# Log raw extractions
print("\n— Raw LLM output —")
for i, e in enumerate(entries, 1):
    print(f"{i:2d}:", e.model_dump())

# === STEP 6: Expand any code ranges ===
def expand_codes(e):
    parts = re.split(r',\s*', e.billing_code)
    out = []
    for p in parts:
        if '-' in p:
            a,b = map(int, re.findall(r'\d+', p))
            for n in range(a, b+1):
                ne = e.model_copy()
                ne.billing_code = str(n)
                out.append(ne)
        else:
            ne = e.model_copy()
            ne.billing_code = p.strip()
            out.append(ne)
    return out

final = []
print("\n— Range expansions —")
for e in entries:
    ex = expand_codes(e)
    print(f"  {e.billing_code} → {[ee.billing_code for ee in ex]}")
    final.extend(ex)

# === STEP 7: To DataFrame, reorder, fill N/A, export ===
df = pd.DataFrame([ee.model_dump() for ee in final])
cols = [
  "hospital","lob","place_of_service","service_category",
  "billing_code_type","billing_code","rate","negotiated_type",
  "additional_information","effective_date"
]
df = df[cols].fillna("N/A")
df.to_excel(OUTPUT_XLSX, index=False)
print(f"\n✅ Written {len(df)} rows to {OUTPUT_XLSX}")

# Show first few rows
df.head()
