# 0) Install dependencies (run once per kernel)
!pip install --quiet pdfminer.six openai instructor pandas openpyxl

# 1) All‐in‐one extraction + parsing + Excel export
import os, re, json
from io import StringIO
from pdfminer.high_level import extract_text_to_fp
from pdfminer.layout import LAParams
from pydantic import BaseModel, Field, field_validator, model_validator
from typing import Optional, List
from openai import OpenAI
import instructor
import pandas as pd

# === CONFIGURATION ===
PDF_PATH     = r"C:\path\to\your_contract.pdf"       # ← your PDF file
OUTPUT_XLSX  = r"C:\path\to\contract_rates.xlsx"     # ← where to save Excel
MODEL_NAME   = "openai/gpt-4o-mini"                  # ← your model or Azure deployment
os.environ["OPENAI_API_KEY"] = "sk-..."              # ← your OpenAI or Azure token

# === 2) Initialize the Instructor client (no external init_model file) ===
CLIENT = None
def init_model():
    global CLIENT
    CLIENT = instructor.from_openai(
        OpenAI(api_key=os.environ["OPENAI_API_KEY"]),
        mode=instructor.Mode.JSON
    )
init_model()

# === 3) Extract embedded text from the PDF via pdfminer.six ===
def extract_pdf_text(path: str) -> str:
    pages = []
    laparams = LAParams()
    for i in range(1000):
        buf = StringIO()
        try:
            extract_text_to_fp(open(path, "rb"), buf,
                               laparams=laparams,
                               page_numbers=[i])
        except IndexError:
            break
        txt = buf.getvalue()
        print(f"[pdfminer] Page {i+1}: {len(txt)} chars")
        if not txt:
            break
        pages.append(txt)
    return "\n".join(pages).strip()

contract_text = extract_pdf_text(PDF_PATH)
if not contract_text:
    raise RuntimeError("No text extracted from PDF—verify it has embedded text.")
print(f"\n✅ Total extracted chars: {len(contract_text)}\n")

# === 4) Define Pydantic schema with validators & N/A fallback ===
class HospitalRateEntry(BaseModel):
    hospital: str = Field(..., description="Facility name")
    lob: str = Field(..., description="Line of business")
    place_of_service: str = Field(..., description="IP or OP")
    service_category: str
    billing_code_type: str
    billing_code: str
    rate: str
    negotiated_type: str
    additional_information: Optional[str] = ""
    effective_date: str

    @field_validator("rate")
    def check_rate(cls, v):
        if not re.match(r"^\$?\d{1,3}(,\d{3})*(\.\d{2})?$|^\d{1,3}%$", v.strip()):
            raise ValueError(f"Invalid rate: {v}")
        return v.strip()

    @field_validator("billing_code")
    def check_code(cls, v):
        if not re.match(r"^[A-Za-z0-9\-, ]+$", v.strip()):
            raise ValueError(f"Invalid code: {v}")
        return v.strip()

    @model_validator(mode="after")
    def fill_na(self):
        for f in self.__fields__:
            val = getattr(self, f)
            if not val or (isinstance(val, str) and not val.strip()):
                setattr(self, f, "N/A")
        return self

# === 5) Ask the model to extract a JSON array of entries ===
prompt = f"""
Extract every billing entry from this hospital contract into a JSON array.
Each object must have exactly these keys:
hospital, lob, place_of_service, service_category,
billing_code_type, billing_code, rate, negotiated_type,
additional_information, effective_date

Here is the contract text:
\"\"\"
{contract_text}
\"\"\"
"""
res = CLIENT.chat.completions.create(
    model=MODEL_NAME,
    messages=[
        {"role":"system","content":"You extract structured JSON only."},
        {"role":"user","content":prompt}
    ],
    temperature=0
)
payload = res.choices[0].message.content
data = json.loads(payload)
entries: List[HospitalRateEntry] = [HospitalRateEntry(**item) for item in data]

print("— Raw extracted entries —")
for i,e in enumerate(entries,1):
    print(f"{i:2d}.", e.model_dump())

# === 6) Expand billing-code ranges (e.g. "190-192") ===
def expand_codes(e: HospitalRateEntry) -> List[HospitalRateEntry]:
    out=[]
    for part in re.split(r',\s*', e.billing_code):
        if '-' in part:
            a,b = map(int, re.findall(r'\d+', part))
            for n in range(a,b+1):
                ne=e.model_copy(); ne.billing_code=str(n); out.append(ne)
            continue
        ne=e.model_copy(); ne.billing_code=part.strip(); out.append(ne)
    return out

final: List[HospitalRateEntry] = []
print("\n— Range expansions —")
for e in entries:
    ex = expand_codes(e)
    print(f" {e.billing_code} → {[x.billing_code for x in ex]}")
    final.extend(ex)

# === 7) To DataFrame, reorder columns, fill N/A, export to Excel ===
df = pd.DataFrame([x.model_dump() for x in final])
cols = [
    "hospital","lob","place_of_service","service_category",
    "billing_code_type","billing_code","rate","negotiated_type",
    "additional_information","effective_date"
]
df = df[cols].fillna("N/A")
df.to_excel(OUTPUT_XLSX, index=False)

print(f"\n✅ Wrote {len(df)} rows to {OUTPUT_XLSX}")
df.head()
