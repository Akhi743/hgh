import fitz
import csv
from pathlib import Path
from typing import List, Dict, Any, Optional
from google.genai import types
import google.genai as genai
from langchain.prompts import PromptTemplate
from langchain.output_parsers import PydanticOutputParser, OutputFixingParser
from pydantic import BaseModel, Field

def pdf_to_images(pdf_path, output_dir=None, dpi=300):
    pdf_path = Path(pdf_path)
    if output_dir is None:
        output_dir = pdf_path.parent
    else:
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
    
    doc = fitz.open(pdf_path)
    image_paths = []
    
    for page_num in range(len(doc)):
        page = doc.load_page(page_num)
        mat = fitz.Matrix(dpi/72, dpi/72)
        pix = page.get_pixmap(matrix=mat)
        
        output_filename = f"{pdf_path.stem}_page_{page_num + 1:03d}.png"
        output_path = output_dir / output_filename
        pix.save(str(output_path))
        image_paths.append(str(output_path))
        
        if page_num == 50:
            break
    
    doc.close()
    return image_paths

class PageData(BaseModel):
    effective_date: Optional[str] = Field(description="Effective date from top right corner only")
    hospital_names: Optional[List[str]] = Field(description="Hospital names from CENTER main header only")
    lob: Optional[str] = Field(description="Line of business from CENTER main header")
    place_of_service: Optional[str] = Field(description="Place of service section header")
    table_rows: List[Dict[str, str]] = Field(description="All table rows: service, billing_codes, rates")

class HospitalExtractor:
    def __init__(self, client, output_dir="extracted_data"):
        self.client = client
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        
        # Document state - persist until found new ones
        self.effective_date = ""
        self.hospital_names = []
        self.current_lob = ""
        self.current_place_of_service = ""
        
        # CSV setup
        self.csv_path = self.output_dir / "hospital_rates.csv"
        with open(self.csv_path, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow(['Hospital_Names', 'LOB', 'Place_of_Service', 'Service_Category', 'Billing_Codes', 'Rates', 'Effective_Date'])
    
    def create_prompt(self):
        parser = PydanticOutputParser(pydantic_object=PageData)
        
        class GeminiLLM:
            def __init__(self, client):
                self.client = client
            def __call__(self, prompt: str) -> str:
                response = self.client.models.generate_content(model='gemini-2.0-flash', contents=[prompt])
                return response.text
        
        llm_wrapper = GeminiLLM(self.client)
        fixing_parser = OutputFixingParser.from_llm(parser=parser, llm=llm_wrapper)
        
        template = """
Extract data from this hospital rate schedule page following these EXACT rules:

1. EFFECTIVE DATE: Look ONLY in top right corner below any system name. Extract just the date, ignore everything else in corners.

2. HOSPITAL NAMES: Look ONLY in the CENTER main header (not corners). Extract actual hospital names from the centered main title.

3. LOB: Extract Line of Business from the CENTER main header (COMMERCIAL, MEDICARE, etc.)

4. PLACE OF SERVICE: Find section headers like:
   - INPATIENT RATES
   - OUTPATIENT RATES  
   - INPATIENT CARVE OUT RATES
   - OUTPATIENT CARVE OUT RATES

5. TABLE ROWS: Extract ALL table rows with:
   - service: Service name/category
   - billing_codes: Billing codes
   - rates: Rate information

IMPORTANT: 
- Only extract hospital names from CENTER main header, NOT from corners
- Only extract effective date from top right corner
- If no new main header found, return empty hospital_names and lob
- If no new place of service found, return empty place_of_service

{format_instructions}
"""
        
        return PromptTemplate(
            template=template,
            input_variables=[],
            partial_variables={"format_instructions": fixing_parser.get_format_instructions()}
        ), fixing_parser
    
    def process_page(self, image_path: str, page_num: int):
        with open(image_path, 'rb') as f:
            image_bytes = f.read()
        
        prompt, parser = self.create_prompt()
        
        response = self.client.models.generate_content(
            model='gemini-2.0-flash',
            contents=[
                types.Part.from_bytes(data=image_bytes, mime_type='image/png'),
                prompt.format()
            ]
        )
        
        data = parser.parse(response.text.strip())
        
        # Update state only when new values found
        if data.effective_date:
            self.effective_date = data.effective_date
        
        if data.hospital_names:
            self.hospital_names = data.hospital_names
            print(f"Page {page_num}: New hospital names: {self.hospital_names}")
        
        if data.lob:
            self.current_lob = data.lob
            print(f"Page {page_num}: New LOB: {self.current_lob}")
        
        if data.place_of_service:
            self.current_place_of_service = data.place_of_service
            print(f"Page {page_num}: New place of service: {self.current_place_of_service}")
        
        # Save table data
        rows_saved = 0
        if data.table_rows:
            self.save_data(data.table_rows)
            rows_saved = len(data.table_rows)
            print(f"Page {page_num}: Saved {rows_saved} rows")
        
        return rows_saved
    
    def save_data(self, table_rows: List[Dict[str, str]]):
        with open(self.csv_path, 'a', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            for row in table_rows:
                writer.writerow([
                    '; '.join(self.hospital_names) if self.hospital_names else '',
                    self.current_lob,
                    self.current_place_of_service,
                    row.get('service', ''),
                    row.get('billing_codes', ''),
                    row.get('rates', ''),
                    self.effective_date
                ])
    
    def extract_pdf(self, pdf_path: str):
        print(f"Processing: {pdf_path}")
        
        image_paths = pdf_to_images(pdf_path, self.output_dir)
        total_rows = 0
        
        for page_num, image_path in enumerate(image_paths, 1):
            try:
                rows = self.process_page(image_path, page_num)
                total_rows += rows
            except Exception as e:
                print(f"Error on page {page_num}: {e}")
        
        print(f"\nExtraction Complete:")
        print(f"Total pages: {len(image_paths)}")
        print(f"Total rows: {total_rows}")
        print(f"Final hospital names: {self.hospital_names}")
        print(f"Final LOB: {self.current_lob}")
        print(f"Final place of service: {self.current_place_of_service}")
        print(f"Effective date: {self.effective_date}")
        print(f"CSV file: {self.csv_path}")
        
        return {
            'total_pages': len(image_paths),
            'total_rows': total_rows,
            'csv_file': str(self.csv_path)
        }

# Usage
if __name__ == "__main__":
    from google import genai
    
    # Initialize client with your project details
    client = genai.Client(vertexai=True, project="your-project-id", location="us-central1")
    
    # Create extractor
    extractor = HospitalExtractor(client, output_dir="extracted_data")
    
    # Process your PDF file - UPDATE THIS PATH
    pdf_file_path = r"C:\path\to\your\hospital_rates.pdf"
    results = extractor.extract_pdf(pdf_file_path)
