import fitz  # PyMuPDF
import os
import csv
import json
import re
from pathlib import Path
from typing import List, Optional, Union, Dict, Any
from google.genai import types
import google.genai as genai
from langchain.prompts import PromptTemplate
from langchain.output_parsers import PydanticOutputParser, OutputFixingParser
from langchain_core.exceptions import OutputParserException
from pydantic import BaseModel, Field
import pandas as pd

def pdf_to_images(pdf_path, output_dir=None, dpi=150, image_format='png'):
    """Convert each page of a PDF to individual images."""
    pdf_path = Path(pdf_path)
    
    if not pdf_path.exists():
        raise FileNotFoundError(f"PDF file not found: {pdf_path}")
    
    if output_dir is None:
        output_dir = pdf_path.parent
    else:
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
    
    doc = fitz.open(pdf_path)
    image_paths = []
    
    for page_num in range(len(doc)):
        page = doc.load_page(page_num)
        mat = fitz.Matrix(dpi/72, dpi/72)
        pix = page.get_pixmap(matrix=mat)
        
        output_filename = f"{pdf_path.stem}_page_{page_num + 1:03d}.{image_format}"
        output_path = output_dir / output_filename
        
        pix.save(str(output_path))
        image_paths.append(str(output_path))
        
        print(f"Saved page {page_num + 1} to {output_path}")
        if page_num == 50:
            print("Limiting to first 50 pages for large PDFs")
            break
    
    doc.close()
    return image_paths

class DocumentContext:
    """Simple context tracking as per requirements."""
    def __init__(self):
        self.hospital_names = []           # Same until new main header
        self.lob = None                   # Same until new main header  
        self.place_of_service = None      # Same until new place of service
        self.effective_date = None        # Same for entire document

class HospitalRateExtractor:
    """Extract hospital rates exactly as specified."""
    
    def __init__(self, client, output_dir: str = None):
        self.client = client
        self.output_dir = Path(output_dir) if output_dir else Path.cwd()
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.context = DocumentContext()
        
        # CSV columns as specified
        self.csv_columns = [
            'Hospital_Names', 'LOB', 'Place_of_Service', 'Service_Category', 
            'Billing_Codes', 'Rates', 'Effective_Date'
        ]
        
        self.csv_path = self.output_dir / "extracted_hospital_rates.csv"
        with open(self.csv_path, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(self.csv_columns)
    
    def extract_text_lines(self, image_path: str) -> List[str]:
        """Extract all text lines from top to bottom."""
        try:
            with open(image_path, 'rb') as f:
                image_bytes = f.read()
            
            mime_type = 'image/png' if image_path.lower().endswith('.png') else 'image/jpeg'
            
            prompt = """
Extract ALL text from this image line by line from top to bottom.
Return each line exactly as it appears.
Maintain the exact order from top to bottom.
"""
            
            response = self.client.models.generate_content(
                model='gemini-2.0-flash',
                contents=[
                    types.Part.from_bytes(data=image_bytes, mime_type=mime_type),
                    prompt
                ]
            )
            
            lines = [line.strip() for line in response.text.strip().split('\n') if line.strip()]
            return lines
            
        except Exception as e:
            print(f"Error extracting text: {e}")
            return []
    
    def extract_effective_date_from_corner(self, lines: List[str]) -> Optional[str]:
        """Extract effective date from top right corner (ignore everything else in corner)."""
        # Look at first few lines for effective date
        for line in lines[:5]:  # Check first 5 lines
            line_lower = line.lower()
            if 'effective date' in line_lower:
                # Extract date from this line
                date_match = re.search(r'(\d{1,2}/\d{1,2}/\d{4})', line)
                if date_match:
                    return date_match.group(1)
                    
                # Also check for date ranges
                range_match = re.search(r'(\d{1,2}/\d{1,2}/\d{4})\s+through\s+(\d{1,2}/\d{1,2}/\d{4})', line)
                if range_match:
                    return f"{range_match.group(1)} through {range_match.group(2)}"
        
        return None
    
    def is_main_header(self, line: str) -> bool:
        """Detect main header with hospital names."""
        line_lower = line.lower()
        
        # Main headers typically contain these patterns
        main_header_patterns = [
            'hospital service and rate schedule',
            'hospital.*service.*rate.*schedule',
            'rate schedule.*hospital',
            'hospital.*rate.*schedule'
        ]
        
        return any(re.search(pattern, line_lower) for pattern in main_header_patterns)
    
    def extract_hospital_and_lob_from_header(self, line: str) -> Dict[str, Any]:
        """Extract hospital names and LOB from main header using AI."""
        try:
            prompt = f"""
Extract hospital names and Line of Business from this main header:

"{line}"

IMPORTANT: 
- Extract actual hospital facility names (not system names like "Mercy Health")
- Extract the Line of Business type

Return in this format:
Hospital Names: [hospital names separated by commas]
LOB: [business line type]
"""
            
            response = self.client.models.generate_content(
                model='gemini-2.0-flash',
                contents=[prompt]
            )
            
            # Parse response
            hospital_names = []
            lob = None
            
            for response_line in response.text.strip().split('\n'):
                if response_line.startswith('Hospital Names:'):
                    names_text = response_line.replace('Hospital Names:', '').strip()
                    hospital_names = [name.strip() for name in names_text.split(',') if name.strip()]
                elif response_line.startswith('LOB:'):
                    lob = response_line.replace('LOB:', '').strip()
            
            return {'hospital_names': hospital_names, 'lob': lob}
                
        except Exception as e:
            print(f"Error extracting from header: {e}")
            return {'hospital_names': [], 'lob': None}
    
    def is_place_of_service_header(self, line: str) -> Optional[str]:
        """Detect place of service headers."""
        line_lower = line.lower().strip()
        
        # Exact matches for place of service headers
        if 'inpatient carve out rates' in line_lower:
            return 'INPATIENT CARVE OUT'
        elif 'outpatient carve out rates' in line_lower:
            return 'OUTPATIENT CARVE OUT'
        elif 'inpatient rates' in line_lower:
            return 'INPATIENT'
        elif 'outpatient rates' in line_lower:
            return 'OUTPATIENT'
        
        return None
    
    def is_table_row(self, line: str) -> bool:
        """Check if line is a table row (not a header)."""
        line_stripped = line.strip()
        
        if not line_stripped or len(line_stripped) < 5:
            return False
            
        line_lower = line_stripped.lower()
        
        # Skip section headers
        skip_headers = [
            'service', 'billing codes', 'billing code', 'rates', 'rate',
            'inpatient rates', 'outpatient rates', 'carve out rates',
            'hospital service', 'rate schedule', 'effective date'
        ]
        
        # If it's exactly a header, skip
        if any(line_lower == header or line_lower == header + ':' for header in skip_headers):
            return False
        
        # If it has substantial content, treat as table row
        return True
    
    def extract_table_row_data(self, line: str) -> Optional[Dict[str, str]]:
        """Extract service category, billing codes, and rates from table row using AI."""
        try:
            prompt = f"""
Parse this table row and extract the three components:

"{line}"

Extract exactly as they appear:
- Service Category: The service name/description  
- Billing Codes: All billing codes (complete text)
- Rates: Rate information (complete text)

Return in this format:
Service Category: [service name]
Billing Codes: [all codes as they appear]  
Rates: [rate information as it appears]
"""
            
            response = self.client.models.generate_content(
                model='gemini-2.0-flash',
                contents=[prompt]
            )
            
            # Parse response
            service_category = ""
            billing_codes = ""
            rates = ""
            
            for response_line in response.text.strip().split('\n'):
                if response_line.startswith('Service Category:'):
                    service_category = response_line.replace('Service Category:', '').strip()
                elif response_line.startswith('Billing Codes:'):
                    billing_codes = response_line.replace('Billing Codes:', '').strip()
                elif response_line.startswith('Rates:'):
                    rates = response_line.replace('Rates:', '').strip()
            
            if service_category or billing_codes or rates:
                return {
                    'service_category': service_category,
                    'billing_codes': billing_codes,
                    'rates': rates
                }
                
        except Exception as e:
            print(f"Error parsing table row: {e}")
        
        return None
    
    def process_page(self, image_path: str, page_num: int) -> Dict[str, Any]:
        """Process page line by line as specified."""
        print(f"\n=== Processing page {page_num} ===")
        
        lines = self.extract_text_lines(image_path)
        print(f"Extracted {len(lines)} lines")
        
        rows_added = 0
        
        # Extract effective date from top right corner (only if not already found)
        if not self.context.effective_date:
            effective_date = self.extract_effective_date_from_corner(lines)
            if effective_date:
                self.context.effective_date = effective_date
                print(f"EFFECTIVE DATE: {effective_date}")
        
        # Process each line from top to bottom
        for i, line in enumerate(lines):
            # Check for main header (hospital names + LOB)
            if self.is_main_header(line):
                header_data = self.extract_hospital_and_lob_from_header(line)
                if header_data['hospital_names']:
                    self.context.hospital_names = header_data['hospital_names']
                    print(f"NEW HOSPITAL HEADER: {self.context.hospital_names}")
                if header_data['lob']:
                    self.context.lob = header_data['lob']
                    print(f"LOB: {self.context.lob}")
                continue
            
            # Check for place of service header  
            pos = self.is_place_of_service_header(line)
            if pos:
                self.context.place_of_service = pos
                print(f"NEW PLACE OF SERVICE: {pos}")
                continue
            
            # Check for table row
            if self.is_table_row(line):
                row_data = self.extract_table_row_data(line)
                if row_data:
                    # Save to CSV with current context
                    csv_row = [
                        '; '.join(self.context.hospital_names) if self.context.hospital_names else 'N/A',
                        self.context.lob or 'N/A',
                        self.context.place_of_service or 'N/A',
                        row_data.get('service_category', 'N/A'),
                        row_data.get('billing_codes', 'N/A'),
                        row_data.get('rates', 'N/A'),
                        self.context.effective_date or 'N/A'
                    ]
                    
                    with open(self.csv_path, 'a', newline='', encoding='utf-8') as csvfile:
                        writer = csv.writer(csvfile)
                        writer.writerow(csv_row)
                    
                    rows_added += 1
                    print(f"  ROW: {row_data.get('service_category', '')[:50]}...")
        
        return {
            'page_num': page_num,
            'rows_added': rows_added,
            'current_context': {
                'hospitals': self.context.hospital_names,
                'lob': self.context.lob,
                'place_of_service': self.context.place_of_service,
                'effective_date': self.context.effective_date
            }
        }
    
    def extract_from_pdf(self, pdf_path: str, dpi: int = 300) -> Dict[str, Any]:
        """Extract from PDF following exact requirements."""
        print(f"Starting extraction for: {pdf_path}")
        
        image_paths = pdf_to_images(pdf_path, self.output_dir, dpi, 'png')
        
        results = {
            'pdf_path': pdf_path,
            'total_pages': len(image_paths),
            'total_rows_extracted': 0,
            'csv_file': str(self.csv_path)
        }
        
        for page_num, image_path in enumerate(image_paths, 1):
            page_result = self.process_page(image_path, page_num)
            results['total_rows_extracted'] += page_result.get('rows_added', 0)
        
        print(f"\n=== EXTRACTION COMPLETE ===")
        print(f"Total pages: {results['total_pages']}")
        print(f"Total rows: {results['total_rows_extracted']}")
        print(f"Final context: {self.context.__dict__}")
        print(f"CSV file: {results['csv_file']}")
        
        return results

# Usage
if __name__ == "__main__":
    pdf_file = "path/to/your/hospital_rates.pdf"
    
    from google import genai
    client = genai.Client(vertexai=True, project="your-project", location="us-central1")
    
    extractor = HospitalRateExtractor(client, output_dir="extracted_data")
    results = extractor.extract_from_pdf(pdf_file)

def extract_hospital_rates(pdf_path: str, project_id: str, location: str = "us-central1", 
                          output_dir: str = "extracted_data", dpi: int = 300):
    """Extract hospital rates following exact specifications."""
    from google import genai
    client = genai.Client(vertexai=True, project=project_id, location=location)
    extractor = HospitalRateExtractor(client, output_dir=output_dir)
    return extractor.extract_from_pdf(pdf_path, dpi=dpi)
