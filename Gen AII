import fitz  # PyMuPDF
import os
import csv
import json
import uuid
from pathlib import Path
from typing import List, Optional, Union, Dict, Any
from google.genai import types
import google.genai as genai
from langchain.prompts import PromptTemplate
from langchain.schema import HumanMessage
from langchain.output_parsers import PydanticOutputParser, OutputFixingParser
from langchain_core.exceptions import OutputParserException
from pydantic import BaseModel, Field
import pandas as pd

def pdf_to_images(pdf_path, output_dir=None, dpi=150, image_format='png'):
    """Convert each page of a PDF to individual images."""
    pdf_path = Path(pdf_path)
   
    if not pdf_path.exists():
        raise FileNotFoundError(f"PDF file not found: {pdf_path}")
   
    if output_dir is None:
        output_dir = pdf_path.parent
    else:
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
   
    doc = fitz.open(pdf_path)
    image_paths = []
   
    for page_num in range(len(doc)):
        page = doc.load_page(page_num)
        mat = fitz.Matrix(dpi/72, dpi/72)
        pix = page.get_pixmap(matrix=mat)
       
        output_filename = f"{pdf_path.stem}_page_{page_num + 1:03d}.{image_format}"
        output_path = output_dir / output_filename
        pix.save(str(output_path))
        image_paths.append(str(output_path))
       
        print(f"Saved page {page_num + 1} to {output_path}")
        if page_num == 20:
            print("Limiting to first 20 pages for large PDFs")
            break
   
    doc.close()
    return image_paths

class TableData(BaseModel):
    """Model for table data extraction with multiple tables per page support."""
    tables_found: List[Dict[str, Any]] = Field(description="List of all tables found on this page")

class SimpleTableExtractor:
    """Simplified table extractor using smart prompts instead of complex logic."""
   
    def __init__(self, client, output_dir: str = None):
        self.client = client
        self.output_dir = Path(output_dir) if output_dir else Path.cwd()
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.table_counter = 1
       
    def create_extraction_prompt(self) -> tuple:
        """Create a comprehensive prompt that handles everything."""
        base_parser = PydanticOutputParser(pydantic_object=TableData)
       
        class GeminiLLM:
            def __init__(self, client):
                self.client = client
               
            def __call__(self, prompt: str) -> str:
                try:
                    response = self.client.models.generate_content(
                        model='gemini-2.0-flash',
                        contents=[prompt]
                    )
                    return response.text
                except Exception as e:
                    return f"Error: {e}"
       
        llm_wrapper = GeminiLLM(self.client)
        table_parser = OutputFixingParser.from_llm(parser=base_parser, llm=llm_wrapper)
       
        template = """
You are an expert at extracting hospital rate schedule data. Analyze this image and extract ALL tables found.

IMPORTANT: You may find multiple tables on one page (e.g., both INPATIENT and OUTPATIENT sections). Extract each as a separate table.

For each table found, provide this information:

1. HOSPITAL NAME (CRITICAL):
   - Extract SPECIFIC hospital facility name (e.g., "Sistersville General Hospital", "Mercy Springfield and Urbana Hospitals")
   - NOT system names like "Mercy Health" or "Memorial Health System"
   - Look in document headers, titles, and rate schedule headers

2. TABLE METADATA:
   - effective_date: Look for "Effective Date:" text
   - lob_type: "Commercial", "Medicare", "Medicaid", "ACOP Commercial", or "N/A"
   - service_type: Determine from section headers:
     * "INPATIENT RATES" → "INPATIENT" 
     * "OUTPATIENT RATES" → "OUTPATIENT"
     * Look at the section each table is under

3. PLACE OF SERVICE LOGIC:
   - If service_type = "INPATIENT" → place_of_service = "IP"
   - If service_type = "OUTPATIENT" → place_of_service = "OP"
   - For individual rows, also check:
     * DRG codes → "IP"
     * Ambulatory Surgery → "OP"
     * Emergency Care → "OP"
     * Laboratory Services → "OP"

4. TABLE DATA:
   For each row in each table, extract:
   - service: Service name/description
   - billing_code_type: "DRG", "Revenue Codes", "HCPC Codes", etc.
   - billing_codes: The actual codes
   - rate_amount: Just the dollar amount or percentage
   - negotiated_type: "Per Diem", "Case Rate", "Percentage", etc.
   - additional_info: Special conditions or "N/A"
   - place_of_service: Use logic above

RESPONSE FORMAT:
Return a list called "tables_found" where each table is:
{{
  "hospital_name": "Specific Hospital Name",
  "effective_date": "MM/DD/YYYY",
  "lob_type": "Commercial",
  "service_type": "INPATIENT" or "OUTPATIENT",
  "table_description": "Brief description",
  "data": [
    {{
      "service": "Service name",
      "billing_code_type": "DRG",
      "billing_codes": "123-456",
      "rate_amount": "$1,200.00",
      "negotiated_type": "Per Diem",
      "additional_info": "N/A",
      "place_of_service": "IP"
    }}
  ]
}}

{format_instructions}

Extract all hospital rate tables from this image:
"""
       
        prompt = PromptTemplate(
            template=template,
            input_variables=[],
            partial_variables={"format_instructions": table_parser.get_format_instructions()}
        )
       
        return prompt, table_parser
   
    def process_page(self, image_path: str, page_num: int) -> List[str]:
        """Process a single page and return list of CSV files created."""
        print(f"Processing page {page_num}: {Path(image_path).name}")
        
        try:
            with open(image_path, 'rb') as f:
                image_bytes = f.read()
           
            mime_type = 'image/png' if image_path.lower().endswith('.png') else 'image/jpeg'
           
            # Extract all tables from the page
            extraction_prompt, extraction_parser = self.create_extraction_prompt()
            extraction_text = extraction_prompt.format()
           
            response = self.client.models.generate_content(
                model='gemini-2.0-flash',
                contents=[
                    types.Part.from_bytes(data=image_bytes, mime_type=mime_type),
                    extraction_text
                ]
            )
           
            parsed_response = extraction_parser.parse(response.text.strip())
            
            csv_files_created = []
            
            # Process each table found
            for table_data in parsed_response.tables_found:
                if table_data.get('data') and len(table_data['data']) > 0:
                    csv_file = self.create_csv_for_table(table_data, page_num)
                    csv_files_created.append(csv_file)
                    print(f"Created CSV: {csv_file}")
                    print(f"  Hospital: {table_data.get('hospital_name', 'N/A')}")
                    print(f"  Service Type: {table_data.get('service_type', 'N/A')}")
                    print(f"  Rows: {len(table_data['data'])}")
            
            return csv_files_created
            
        except Exception as e:
            print(f"Error processing page {page_num}: {e}")
            return []
    
    def create_csv_for_table(self, table_data: Dict[str, Any], page_num: int) -> str:
        """Create a CSV file for a single table."""
        
        # Generate filename
        service_type = table_data.get('service_type', 'UNKNOWN').lower()
        hospital_name = table_data.get('hospital_name', 'Unknown')
        safe_hospital = "".join(c for c in hospital_name if c.isalnum() or c in (' ', '-', '_')).rstrip()[:20]
        
        csv_filename = f"table_{self.table_counter}_{safe_hospital}_{service_type}_page{page_num}.csv"
        csv_path = self.output_dir / csv_filename
        self.table_counter += 1
        
        # Standard columns
        columns = [
            'Hospital', 'LOB', 'Place of Service', 'Service Category', 
            'Billing Code Type', 'Billing Code', 'Rate', 'Negotiated Type',
            'Additional Information', 'Effective Date'
        ]
        
        # Write CSV
        with open(csv_path, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(columns)
            
            for row in table_data.get('data', []):
                writer.writerow([
                    table_data.get('hospital_name', 'N/A'),
                    table_data.get('lob_type', 'N/A'),
                    row.get('place_of_service', 'N/A'),
                    row.get('service', 'N/A'),
                    row.get('billing_code_type', 'N/A'),
                    row.get('billing_codes', 'N/A'),
                    row.get('rate_amount', 'N/A'),
                    row.get('negotiated_type', 'N/A'),
                    row.get('additional_info', 'N/A'),
                    table_data.get('effective_date', 'N/A')
                ])
        
        return str(csv_path)
   
    def extract_tables_from_pdf(self, pdf_path: str, dpi: int = 150, image_format: str = 'png') -> Dict[str, Any]:
        """Extract all tables from PDF."""
        print(f"Starting extraction for: {pdf_path}")
       
        # Convert PDF to images
        image_paths = pdf_to_images(pdf_path, self.output_dir, dpi, image_format)
       
        # Process each page
        all_csv_files = []
        for page_num, image_path in enumerate(image_paths, 1):
            csv_files = self.process_page(image_path, page_num)
            all_csv_files.extend(csv_files)
       
        # Summary
        print(f"\n=== EXTRACTION SUMMARY ===")
        print(f"Total pages processed: {len(image_paths)}")
        print(f"Total CSV files created: {len(all_csv_files)}")
        
        if all_csv_files:
            print(f"\nCSV Files Created:")
            for csv_file in all_csv_files:
                print(f"  - {csv_file}")
       
        return {
            'pdf_path': pdf_path,
            'total_pages': len(image_paths),
            'csv_files': all_csv_files,
            'total_tables': len(all_csv_files)
        }

# Usage example
if __name__ == "__main__":
    pdf_file = r"C:\Users\N873855\Documents\extracted_tables\Mercy_health.pdf"
   
    from google import genai
    client = genai.Client(vertexai=True, project="anbc-hcb-dev", location="us-central1")
   
    extractor = SimpleTableExtractor(client, output_dir="extracted_tables")
    results = extractor.extract_tables_from_pdf(pdf_file, dpi=300)
   
    print("Simple table extractor ready!")
