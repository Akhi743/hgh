import fitz  # PyMuPDF
import os
import csv
import json
import re
from pathlib import Path
from typing import List, Optional, Union, Dict, Any
from google.genai import types
import google.genai as genai
from langchain.prompts import PromptTemplate
from langchain.output_parsers import PydanticOutputParser, OutputFixingParser
from langchain_core.exceptions import OutputParserException
from pydantic import BaseModel, Field
import pandas as pd

def pdf_to_images(pdf_path, output_dir=None, dpi=150, image_format='png'):
    """Convert each page of a PDF to individual images."""
    pdf_path = Path(pdf_path)
    
    if not pdf_path.exists():
        raise FileNotFoundError(f"PDF file not found: {pdf_path}")
    
    if output_dir is None:
        output_dir = pdf_path.parent
    else:
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
    
    doc = fitz.open(pdf_path)
    image_paths = []
    
    for page_num in range(len(doc)):
        page = doc.load_page(page_num)
        mat = fitz.Matrix(dpi/72, dpi/72)
        pix = page.get_pixmap(matrix=mat)
        
        output_filename = f"{pdf_path.stem}_page_{page_num + 1:03d}.{image_format}"
        output_path = output_dir / output_filename
        
        pix.save(str(output_path))
        image_paths.append(str(output_path))
        
        print(f"Saved page {page_num + 1} to {output_path}")
        if page_num == 50:  # Limit for large PDFs
            print("Limiting to first 50 pages for large PDFs")
            break
    
    doc.close()
    return image_paths

class PageText(BaseModel):
    """Text extraction from page with line-by-line structure."""
    lines: List[str] = Field(description="All text lines from top to bottom of the page")

class TableRow(BaseModel):
    """Single table row extraction."""
    service: str = Field(description="Service name")
    billing_codes: str = Field(description="Billing codes")
    rates: str = Field(description="Rates information")

class DocumentContext:
    """Line-by-line context tracking."""
    def __init__(self):
        self.current_hospital_names = []
        self.current_lob = None
        self.current_effective_date = None
        self.current_place_of_service = None
        
    def update_hospital_names(self, names: List[str]):
        """Update hospital names."""
        self.current_hospital_names = names
        
    def update_lob(self, lob: str):
        """Update LOB."""
        self.current_lob = lob
        
    def update_effective_date(self, date: str):
        """Update effective date."""
        self.current_effective_date = date
        
    def update_place_of_service(self, pos: str):
        """Update place of service."""
        self.current_place_of_service = pos

class LineByLineExtractor:
    """Line-by-line hospital rate extractor."""
    
    def __init__(self, client, output_dir: str = None):
        self.client = client
        self.output_dir = Path(output_dir) if output_dir else Path.cwd()
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.context = DocumentContext()
        
        # CSV setup
        self.csv_columns = [
            'Hospital_Names', 'LOB', 'Place_of_Service', 'Service', 
            'Billing_Codes', 'Rates', 'Effective_Date'
        ]
        
        self.csv_path = self.output_dir / "extracted_hospital_rates.csv"
        with open(self.csv_path, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(self.csv_columns)
    
    def extract_text_lines(self, image_path: str) -> List[str]:
        """Extract all text lines from image using AI."""
        try:
            with open(image_path, 'rb') as f:
                image_bytes = f.read()
            
            mime_type = 'image/png' if image_path.lower().endswith('.png') else 'image/jpeg'
            
            prompt = """
Extract ALL text from this image line by line from top to bottom.
Return each line of text exactly as it appears.
Include headers, table headers, table rows, and all text.
Maintain the order from top to bottom.
Ignore page numbers and footers at the very bottom.

Return the text as a simple list of lines, one line per row.
"""
            
            response = self.client.models.generate_content(
                model='gemini-2.0-flash',
                contents=[
                    types.Part.from_bytes(data=image_bytes, mime_type=mime_type),
                    prompt
                ]
            )
            
            # Split response into lines
            lines = [line.strip() for line in response.text.strip().split('\n') if line.strip()]
            return lines
            
        except Exception as e:
            print(f"Error extracting text: {e}")
            return []
    
    def is_main_header(self, line: str) -> bool:
        """Check if line is a main document header with hospital names."""
        line_lower = line.lower()
        
        # Skip system names from corners
        if any(skip in line_lower for skip in ['mercy health', 'memorial health system']):
            return False
            
        # Look for hospital indicators in centered headers
        hospital_indicators = ['hospital', 'medical center', 'health center', 'healthcare']
        has_hospital = any(indicator in line_lower for indicator in hospital_indicators)
        
        # Check if it looks like a main header (has hospital service/rate schedule context)
        has_header_context = any(context in line_lower for context in [
            'hospital service', 'rate schedule', 'service and rate'
        ])
        
        return has_hospital or has_header_context
    
    def extract_hospital_names(self, line: str) -> List[str]:
        """Extract hospital names from main header line."""
        # Remove common header words
        clean_line = re.sub(r'\b(hospital|service|and|rate|schedule)\b', '', line, flags=re.IGNORECASE)
        
        # Look for hospital names
        hospital_names = []
        
        # Pattern 1: Names with "Hospital"
        hospital_matches = re.findall(r'([A-Za-z\s]+Hospital)', line, re.IGNORECASE)
        hospital_names.extend([match.strip() for match in hospital_matches])
        
        # Pattern 2: Names with "Medical Center"
        medical_matches = re.findall(r'([A-Za-z\s]+Medical Center)', line, re.IGNORECASE)
        hospital_names.extend([match.strip() for match in medical_matches])
        
        # Pattern 3: Names with TIN numbers
        tin_matches = re.findall(r'([A-Za-z\s]+)\s+TIN\s+\d+', line, re.IGNORECASE)
        hospital_names.extend([match.strip() for match in tin_matches])
        
        return [name for name in hospital_names if len(name) > 3]
    
    def extract_lob(self, line: str) -> Optional[str]:
        """Extract LOB from line."""
        line_lower = line.lower()
        
        if 'commercial' in line_lower:
            if 'acop' in line_lower:
                return 'ACOP Commercial'
            elif 'gatekeeper' in line_lower:
                return 'Commercial'
            else:
                return 'Commercial'
        elif 'medicare' in line_lower:
            return 'Medicare'
        elif 'medicaid' in line_lower:
            return 'Medicaid'
        elif 'hmo' in line_lower:
            return 'HMO'
        elif 'ppo' in line_lower:
            return 'PPO'
        
        return None
    
    def extract_effective_date(self, line: str) -> Optional[str]:
        """Extract effective date from line."""
        # Look for date patterns
        date_patterns = [
            r'effective date[:\s]+(\d{1,2}/\d{1,2}/\d{4})',
            r'(\d{1,2}/\d{1,2}/\d{4})\s+through\s+(\d{1,2}/\d{1,2}/\d{4})',
            r'effective[:\s]+(\d{1,2}/\d{1,2}/\d{4})'
        ]
        
        for pattern in date_patterns:
            match = re.search(pattern, line, re.IGNORECASE)
            if match:
                return match.group(1) if len(match.groups()) == 1 else f"{match.group(1)} through {match.group(2)}"
        
        return None
    
    def is_place_of_service_header(self, line: str) -> Optional[str]:
        """Check if line is a place of service header."""
        line_lower = line.lower()
        
        if 'inpatient carve out rates' in line_lower:
            return 'INPATIENT CARVE OUT'
        elif 'outpatient carve out rates' in line_lower:
            return 'OUTPATIENT CARVE OUT'
        elif 'inpatient rates' in line_lower:
            return 'INPATIENT'
        elif 'outpatient rates' in line_lower:
            return 'OUTPATIENT'
        
        return None
    
    def is_table_row(self, line: str) -> bool:
        """Check if line appears to be a table row."""
        # Simple heuristic: contains service-like text and some structure
        line_lower = line.lower()
        
        # Skip obvious headers
        if any(header in line_lower for header in ['service', 'billing codes', 'rates']):
            return False
        
        # Look for common service patterns
        service_patterns = [
            'surgery', 'care', 'treatment', 'procedure', 'study', 'therapy',
            'catheterization', 'emergency', 'laboratory', 'radiology',
            'observation', 'chemotherapy', 'dialysis'
        ]
        
        has_service = any(pattern in line_lower for pattern in service_patterns)
        
        # Look for code patterns
        has_codes = bool(re.search(r'\b(drg|cpt|hcpc|revenue)\b', line_lower))
        
        # Look for rate patterns
        has_rates = bool(re.search(r'(\$[\d,]+|\d+%|per diem|case rate)', line_lower))
        
        return has_service or has_codes or has_rates
    
    def extract_table_row(self, line: str) -> Optional[TableRow]:
        """Extract table row data from line."""
        if not self.is_table_row(line):
            return None
        
        try:
            # Use AI to parse the table row
            prompt = f"""
Parse this table row and extract the service, billing codes, and rates:

"{line}"

Extract:
- service: The service name/description
- billing_codes: All billing codes (DRG, CPT4, HCPC, Revenue codes, etc.)
- rates: The rate information (amounts, percentages, etc.)

Return in this exact format:
Service: [service name]
Billing Codes: [all codes]
Rates: [rate information]
"""
            
            response = self.client.models.generate_content(
                model='gemini-2.0-flash',
                contents=[prompt]
            )
            
            # Parse the response
            lines = response.text.strip().split('\n')
            service = ""
            billing_codes = ""
            rates = ""
            
            for line in lines:
                if line.startswith('Service:'):
                    service = line.replace('Service:', '').strip()
                elif line.startswith('Billing Codes:'):
                    billing_codes = line.replace('Billing Codes:', '').strip()
                elif line.startswith('Rates:'):
                    rates = line.replace('Rates:', '').strip()
            
            if service or billing_codes or rates:
                return TableRow(
                    service=service,
                    billing_codes=billing_codes,
                    rates=rates
                )
                
        except Exception as e:
            print(f"Error parsing table row: {e}")
        
        return None
    
    def process_page(self, image_path: str, page_num: int) -> Dict[str, Any]:
        """Process page line by line."""
        print(f"\n=== Processing page {page_num} line by line ===")
        
        # Extract all text lines
        lines = self.extract_text_lines(image_path)
        print(f"Extracted {len(lines)} lines")
        
        rows_added = 0
        
        # Process each line from top to bottom
        for i, line in enumerate(lines):
            print(f"Line {i+1}: {line[:100]}...")
            
            # Check for main header
            if self.is_main_header(line):
                hospital_names = self.extract_hospital_names(line)
                if hospital_names:
                    self.context.update_hospital_names(hospital_names)
                    print(f"  NEW HOSPITAL HEADER: {hospital_names}")
                
                lob = self.extract_lob(line)
                if lob:
                    self.context.update_lob(lob)
                    print(f"  LOB: {lob}")
                
                effective_date = self.extract_effective_date(line)
                if effective_date:
                    self.context.update_effective_date(effective_date)
                    print(f"  Effective Date: {effective_date}")
            
            # Check for place of service header
            pos = self.is_place_of_service_header(line)
            if pos:
                self.context.update_place_of_service(pos)
                print(f"  NEW PLACE OF SERVICE: {pos}")
            
            # Check for table row
            table_row = self.extract_table_row(line)
            if table_row:
                # Save to CSV
                csv_row = [
                    '; '.join(self.context.current_hospital_names) if self.context.current_hospital_names else 'N/A',
                    self.context.current_lob or 'N/A',
                    self.context.current_place_of_service or 'N/A',
                    table_row.service or 'N/A',
                    table_row.billing_codes or 'N/A',
                    table_row.rates or 'N/A',
                    self.context.current_effective_date or 'N/A'
                ]
                
                with open(self.csv_path, 'a', newline='', encoding='utf-8') as csvfile:
                    writer = csv.writer(csvfile)
                    writer.writerow(csv_row)
                
                rows_added += 1
                print(f"  TABLE ROW: {table_row.service}")
        
        return {
            'page_num': page_num,
            'rows_added': rows_added,
            'context': {
                'hospitals': self.context.current_hospital_names,
                'lob': self.context.current_lob,
                'place_of_service': self.context.current_place_of_service
            }
        }
    
    def extract_from_pdf(self, pdf_path: str, dpi: int = 300) -> Dict[str, Any]:
        """Extract from PDF line by line."""
        print(f"Starting line-by-line extraction for: {pdf_path}")
        
        image_paths = pdf_to_images(pdf_path, self.output_dir, dpi, 'png')
        
        results = {
            'pdf_path': pdf_path,
            'total_pages': len(image_paths),
            'total_rows_extracted': 0,
            'csv_file': str(self.csv_path)
        }
        
        for page_num, image_path in enumerate(image_paths, 1):
            page_result = self.process_page(image_path, page_num)
            results['total_rows_extracted'] += page_result.get('rows_added', 0)
        
        print(f"\n=== EXTRACTION COMPLETE ===")
        print(f"Total pages: {results['total_pages']}")
        print(f"Total rows: {results['total_rows_extracted']}")
        print(f"CSV file: {results['csv_file']}")
        
        return results

# Usage
if __name__ == "__main__":
    pdf_file = "path/to/your/hospital_rates.pdf"
    
    from google import genai
    client = genai.Client(vertexai=True, project="your-project", location="us-central1")
    
    extractor = LineByLineExtractor(client, output_dir="extracted_data")
    results = extractor.extract_from_pdf(pdf_file)
    
    print("Line-by-line extraction completed!")
