import fitz  # PyMuPDF
import os
import csv
import json
import uuid
from pathlib import Path
from typing import List, Optional, Union, Dict, Any
from google.genai import types
import google.genai as genai
from langchain.prompts import PromptTemplate
from langchain.output_parsers import PydanticOutputParser, OutputFixingParser
from langchain_core.exceptions import OutputParserException
from pydantic import BaseModel, Field
import pandas as pd

def pdf_to_images(pdf_path, output_dir=None, dpi=150, image_format='png'):
    """Convert each page of a PDF to individual images."""
    pdf_path = Path(pdf_path)
    
    if not pdf_path.exists():
        raise FileNotFoundError(f"PDF file not found: {pdf_path}")
    
    if output_dir is None:
        output_dir = pdf_path.parent
    else:
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
    
    doc = fitz.open(pdf_path)
    image_paths = []
    
    for page_num in range(len(doc)):
        page = doc.load_page(page_num)
        mat = fitz.Matrix(dpi/72, dpi/72)
        pix = page.get_pixmap(matrix=mat)
        
        output_filename = f"{pdf_path.stem}_page_{page_num + 1:03d}.{image_format}"
        output_path = output_dir / output_filename
        
        pix.save(str(output_path))
        image_paths.append(str(output_path))
        
        print(f"Saved page {page_num + 1} to {output_path}")
        if page_num == 50:
            print("Limiting to first 50 pages for large PDFs")
            break
    
    doc.close()
    return image_paths

class PageAnalysis(BaseModel):
    """Analysis of page content with clear hierarchy detection."""
    effective_date: Optional[str] = Field(default=None, description="Effective date from top right corner")
    
    # Main header detection
    has_new_main_header: bool = Field(description="Whether page has new main document header in center")
    hospital_names: Optional[List[str]] = Field(default=None, description="Hospital names from main centered header")
    lob_type: Optional[str] = Field(default=None, description="Line of Business from main header")
    
    # Place of service detection
    current_place_of_service: Optional[str] = Field(default=None, description="Current place of service section")
    
    # Table data
    table_rows: List[Dict[str, str]] = Field(description="All table rows with service, billing_codes, rates")

class DocumentState:
    """Maintains document state across pages."""
    def __init__(self):
        self.effective_date = None
        self.current_hospital_names = []
        self.current_lob = None
        self.current_place_of_service = None
        
    def update_effective_date(self, date: str):
        if date and date != "N/A":
            self.effective_date = date
            
    def update_main_header(self, hospital_names: List[str], lob: str):
        if hospital_names:
            self.current_hospital_names = hospital_names
        if lob and lob != "N/A":
            self.current_lob = lob
            
    def update_place_of_service(self, place_of_service: str):
        if place_of_service and place_of_service != "N/A":
            self.current_place_of_service = place_of_service

class HospitalRateExtractor:
    """Customized extractor for hospital rate schedules."""
    
    def __init__(self, client, output_dir: str = None):
        self.client = client
        self.output_dir = Path(output_dir) if output_dir else Path.cwd()
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.state = DocumentState()
        
        # CSV columns
        self.csv_columns = [
            'Hospital_Names', 'LOB', 'Place_of_Service', 'Service_Category', 
            'Billing_Codes', 'Rates', 'Effective_Date'
        ]
        
        # Initialize CSV file
        self.csv_path = self.output_dir / "hospital_rates_extracted.csv"
        with open(self.csv_path, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(self.csv_columns)
    
    def create_extraction_prompt(self) -> tuple:
        """Create prompt for page analysis and extraction."""
        base_parser = PydanticOutputParser(pydantic_object=PageAnalysis)
        
        class GeminiLLM:
            def __init__(self, client):
                self.client = client
                
            def __call__(self, prompt: str) -> str:
                try:
                    response = self.client.models.generate_content(
                        model='gemini-2.0-flash',
                        contents=[prompt]
                    )
                    return response.text
                except Exception as e:
                    return f"Error: {e}"
        
        llm_wrapper = GeminiLLM(self.client)
        parser = OutputFixingParser.from_llm(parser=base_parser, llm=llm_wrapper)
        
        template = """
You are an expert at analyzing hospital rate schedule documents with strict hierarchy detection.

CRITICAL INSTRUCTIONS:

1. EFFECTIVE DATE EXTRACTION:
   - Look ONLY in the top right corner for "Effective Date:" followed by a date
   - Extract the complete date (e.g., "09/01/2024", "06/01/2025", "6/1/2025 through 5/31/2026")
   - IGNORE all other text in the top right corner

2. MAIN HEADER DETECTION:
   - Look for LARGE CENTERED TEXT that contains hospital names
   - Examples: "Sistersville General Hospital", "Mercy Springfield and Urbana Hospitals"
   - These appear as document titles, not in corners or footers
   - If found, extract hospital names and LOB type from this main header
   - LOB examples: "COMMERCIAL", "MEDICARE", "MEDICAID", "ACOP COMMERCIAL"

3. PLACE OF SERVICE DETECTION:
   - Look for section headers like:
     * "INPATIENT RATES:" → "INPATIENT"
     * "OUTPATIENT RATES:" → "OUTPATIENT"
     * "INPATIENT CARVE OUT RATES:" → "INPATIENT CARVE OUT"
     * "OUTPATIENT CARVE OUT RATES:" → "OUTPATIENT CARVE OUT"
   - Extract the current place of service for this page

4. TABLE DATA EXTRACTION:
   - Extract ALL rows from tables under the current place of service
   - For each row extract:
     * service: Service name/description (first column)
     * billing_codes: Complete billing codes (second column)
     * rates: Complete rate information (third column)
   - Count rows visually and ensure you extract ALL of them
   - DO NOT miss any rows

VALIDATION CHECKLIST:
- Did I find the effective date in top right corner?
- Did I detect any new main headers with hospital names?
- Did I identify the current place of service section?
- Did I extract every single table row I can see?

{format_instructions}

Analyze this page and extract all information:
"""
        
        prompt = PromptTemplate(
            template=template,
            input_variables=[],
            partial_variables={"format_instructions": parser.get_format_instructions()}
        )
        
        return prompt, parser
    
    def process_page(self, image_path: str, page_num: int) -> Dict[str, Any]:
        """Process a single page with state management."""
        print(f"Processing page {page_num}: {Path(image_path).name}")
        
        try:
            with open(image_path, 'rb') as f:
                image_bytes = f.read()
            
            mime_type = 'image/png' if image_path.lower().endswith('.png') else 'image/jpeg'
            
            # Extract page content
            prompt, parser = self.create_extraction_prompt()
            prompt_text = prompt.format()
            
            response = self.client.models.generate_content(
                model='gemini-2.0-flash',
                contents=[
                    types.Part.from_bytes(data=image_bytes, mime_type=mime_type),
                    prompt_text
                ]
            )
            
            parsed_data = parser.parse(response.text.strip())
            
            # Update document state
            if parsed_data.effective_date:
                self.state.update_effective_date(parsed_data.effective_date)
                print(f"  Effective Date: {parsed_data.effective_date}")
            
            if parsed_data.has_new_main_header:
                self.state.update_main_header(
                    parsed_data.hospital_names or [], 
                    parsed_data.lob_type or ""
                )
                print(f"  New Main Header - Hospitals: {self.state.current_hospital_names}")
                print(f"  LOB: {self.state.current_lob}")
            
            if parsed_data.current_place_of_service:
                self.state.update_place_of_service(parsed_data.current_place_of_service)
                print(f"  Place of Service: {self.state.current_place_of_service}")
            
            # Process table data
            rows_added = 0
            if parsed_data.table_rows:
                rows_added = self.save_table_data(parsed_data.table_rows)
                print(f"  Extracted {rows_added} table rows")
                
                # Log first few rows for verification
                for i, row in enumerate(parsed_data.table_rows[:3]):
                    print(f"    Row {i+1}: {row.get('service', 'N/A')[:50]}...")
            else:
                print(f"  No table data found")
            
            return {
                'page_num': page_num,
                'effective_date_found': bool(parsed_data.effective_date),
                'new_main_header': parsed_data.has_new_main_header,
                'place_of_service_updated': bool(parsed_data.current_place_of_service),
                'rows_extracted': rows_added,
                'current_state': {
                    'hospitals': self.state.current_hospital_names,
                    'lob': self.state.current_lob,
                    'place_of_service': self.state.current_place_of_service,
                    'effective_date': self.state.effective_date
                }
            }
            
        except Exception as e:
            print(f"Error processing page {page_num}: {e}")
            return {
                'page_num': page_num,
                'error': str(e),
                'rows_extracted': 0
            }
    
    def save_table_data(self, table_rows: List[Dict[str, str]]) -> int:
        """Save table data to CSV with current document state."""
        if not table_rows:
            return 0
            
        rows_to_write = []
        
        for row_data in table_rows:
            csv_row = [
                '; '.join(self.state.current_hospital_names) if self.state.current_hospital_names else 'N/A',
                self.state.current_lob or 'N/A',
                self.state.current_place_of_service or 'N/A',
                row_data.get('service', 'N/A'),
                row_data.get('billing_codes', 'N/A'),
                row_data.get('rates', 'N/A'),
                self.state.effective_date or 'N/A'
            ]
            rows_to_write.append(csv_row)
        
        # Append to CSV
        with open(self.csv_path, 'a', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerows(rows_to_write)
        
        return len(rows_to_write)
    
    def extract_from_pdf(self, pdf_path: str, dpi: int = 300) -> Dict[str, Any]:
        """Extract all data from PDF with state management."""
        print(f"Starting extraction for: {pdf_path}")
        
        # Convert PDF to images
        image_paths = pdf_to_images(pdf_path, self.output_dir, dpi, 'png')
        
        # Process each page
        results = {
            'pdf_path': pdf_path,
            'total_pages': len(image_paths),
            'pages_processed': [],
            'total_rows_extracted': 0,
            'final_state': {},
            'csv_file': str(self.csv_path)
        }
        
        for page_num, image_path in enumerate(image_paths, 1):
            page_result = self.process_page(image_path, page_num)
            results['pages_processed'].append(page_result)
            results['total_rows_extracted'] += page_result.get('rows_extracted', 0)
        
        # Final state
        results['final_state'] = {
            'hospitals': self.state.current_hospital_names,
            'lob': self.state.current_lob,
            'place_of_service': self.state.current_place_of_service,
            'effective_date': self.state.effective_date
        }
        
        # Summary
        print(f"\n=== EXTRACTION SUMMARY ===")
        print(f"Total pages: {results['total_pages']}")
        print(f"Total rows extracted: {results['total_rows_extracted']}")
        print(f"Final hospitals: {self.state.current_hospital_names}")
        print(f"Final LOB: {self.state.current_lob}")
        print(f"Effective date: {self.state.effective_date}")
        print(f"CSV file: {results['csv_file']}")
        
        return results

# Usage
if __name__ == "__main__":
    # Initialize Google AI client
    from google import genai
    client = genai.Client(vertexai=True, project="your-project-id", location="us-central1")
    
    # Create extractor
    extractor = HospitalRateExtractor(client, output_dir="extracted_data")
    
    # Process PDF
    pdf_file = "path/to/your/hospital_rates.pdf"
    results = extractor.extract_from_pdf(pdf_file)
    
    print("Extraction completed!")
