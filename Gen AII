import fitz  # PyMuPDF
import os
import csv
import json
import uuid
from pathlib import Path
from typing import List, Optional, Union, Dict, Any
from google.genai import types
import google.genai as genai
from langchain.prompts import PromptTemplate
from langchain.schema import HumanMessage
from langchain.output_parsers import PydanticOutputParser, OutputFixingParser
from langchain_core.exceptions import OutputParserException
from pydantic import BaseModel, Field
import pandas as pd
import re

def pdf_to_images(pdf_path, output_dir=None, dpi=150, image_format='png'):
    """
    Convert each page of a PDF to individual images.
    """
    pdf_path = Path(pdf_path)
   
    if not pdf_path.exists():
        raise FileNotFoundError(f"PDF file not found: {pdf_path}")
   
    if output_dir is None:
        output_dir = pdf_path.parent
    else:
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
   
    doc = fitz.open(pdf_path)
    image_paths = []
   
    for page_num in range(len(doc)):
        page = doc.load_page(page_num)
       
        # Create transformation matrix for DPI
        mat = fitz.Matrix(dpi/72, dpi/72)
        pix = page.get_pixmap(matrix=mat)
       
        # Generate output filename
        output_filename = f"{pdf_path.stem}_page_{page_num + 1:03d}.{image_format}"
        output_path = output_dir / output_filename
       
        # Save image
        pix.save(str(output_path))
        image_paths.append(str(output_path))
       
        print(f"Saved page {page_num + 1} to {output_path}")
        if page_num == 20:  # Limit to first 20 pages for large PDFs
            print("Limiting to first 20 pages for large PDFs")
            break
   
    doc.close()
    return image_paths

class HospitalRateData(BaseModel):
    """
    Enhanced model for hospital rate data extraction with better structure.
    """
    has_table: bool = Field(description="Whether a structured data table is present")
    table_type: Optional[str] = Field(default=None, description="'header_with_data', 'continuation', or 'none'")
    
    # Document metadata - extracted from headers/titles
    health_system: Optional[str] = Field(default=None, description="Health system name (e.g., 'Mercy Health', 'Advocate Health')")
    hospital_names: Optional[List[str]] = Field(default=None, description="Specific hospital facility names from document")
    effective_date: Optional[str] = Field(default=None, description="Effective date from document")
    lob_type: Optional[str] = Field(default=None, description="Line of Business: Commercial, Medicare, Medicaid, ACOP Commercial, etc.")
    
    # Table structure
    service_setting: Optional[str] = Field(default=None, description="INPATIENT or OUTPATIENT")
    carve_out_section: Optional[str] = Field(default=None, description="Regular rates or carve-out rates section")
    
    # Table data - simplified structure
    table_rows: Optional[List[Dict[str, str]]] = Field(default=None, description="Extracted table rows")
    
    # Context for multi-page processing
    is_continuation: bool = Field(default=False, description="Whether this is a continuation page")
    page_context: Optional[str] = Field(default=None, description="Context about what type of page this is")

class ImprovedTableRegistry:
    """
    Improved registry with better hospital name handling and standardized output.
    """
    def __init__(self, output_dir: Path):
        self.active_tables: Dict[str, Dict[str, Any]] = {}
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # Enhanced standard columns
        self.standard_columns = [
            'Health_System',
            'Hospital_Name', 
            'LOB_Type',
            'Service_Setting',
            'Section_Type',
            'Service_Description',
            'Billing_Code_Type',
            'Billing_Codes',
            'Rate_Amount',
            'Rate_Type',
            'Additional_Notes',
            'Effective_Date',
            'Page_Number'
        ]
        
        # Document-level metadata
        self.document_metadata = {
            'health_system': None,
            'hospital_names': [],
            'effective_date': None,
            'lob_type': None
        }
    
    def update_document_metadata(self, extraction_data: HospitalRateData):
        """Update document-level metadata from extraction."""
        if extraction_data.health_system and not self.document_metadata['health_system']:
            self.document_metadata['health_system'] = extraction_data.health_system
            
        if extraction_data.hospital_names:
            for hospital in extraction_data.hospital_names:
                if hospital not in self.document_metadata['hospital_names']:
                    self.document_metadata['hospital_names'].append(hospital)
                    
        if extraction_data.effective_date and not self.document_metadata['effective_date']:
            self.document_metadata['effective_date'] = extraction_data.effective_date
            
        if extraction_data.lob_type and not self.document_metadata['lob_type']:
            self.document_metadata['lob_type'] = extraction_data.lob_type
    
    def determine_hospital_name(self, hospital_names: List[str]) -> str:
        """Determine the most specific hospital name."""
        if not hospital_names:
            return self.document_metadata['hospital_names'][0] if self.document_metadata['hospital_names'] else "Unknown Hospital"
        
        # Prefer specific hospital names over generic ones
        for name in hospital_names:
            # Look for specific hospital indicators
            if any(indicator in name.lower() for indicator in ['hospital', 'medical center', 'general', 'regional']):
                return name
        
        # Fall back to first name or document-level names
        return hospital_names[0] if hospital_names else (
            self.document_metadata['hospital_names'][0] if self.document_metadata['hospital_names'] else "Unknown Hospital"
        )
    
    def register_new_table(self, extraction_data: HospitalRateData, page_num: int) -> str:
        """Register a new table with improved metadata handling."""
        table_id = str(uuid.uuid4())
        
        # Update document metadata
        self.update_document_metadata(extraction_data)
        
        # Determine specific hospital name
        hospital_name = self.determine_hospital_name(extraction_data.hospital_names)
        
        # Create CSV filename with better naming
        service_setting = extraction_data.service_setting or "UNKNOWN"
        csv_filename = f"rates_{service_setting}_{table_id[:8]}_page_{page_num}.csv"
        csv_path = self.output_dir / csv_filename
        
        # Store table metadata
        table_metadata = {
            'table_id': table_id,
            'csv_path': str(csv_path),
            'csv_filename': csv_filename,
            'start_page': page_num,
            'last_page': page_num,
            'health_system': self.document_metadata['health_system'],
            'hospital_name': hospital_name,
            'lob_type': self.document_metadata['lob_type'],
            'service_setting': extraction_data.service_setting,
            'carve_out_section': extraction_data.carve_out_section,
            'effective_date': self.document_metadata['effective_date'],
            'row_count': 0
        }
        
        self.active_tables[table_id] = table_metadata
        
        # Create CSV with headers
        with open(csv_path, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(self.standard_columns)
        
        return table_id
    
    def add_rows_to_table(self, table_id: str, extraction_data: HospitalRateData, page_num: int):
        """Add rows to existing table with improved data processing."""
        if table_id not in self.active_tables:
            return
        
        table_info = self.active_tables[table_id]
        table_info['last_page'] = page_num
        
        if not extraction_data.table_rows:
            return
        
        # Convert extracted rows to standard format
        standardized_rows = []
        for row_data in extraction_data.table_rows:
            standardized_row = self.convert_row_to_standard_format(row_data, table_info, page_num)
            standardized_rows.append(standardized_row)
        
        # Append to CSV
        csv_path = table_info['csv_path']
        with open(csv_path, 'a', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            for row in standardized_rows:
                writer.writerow([row.get(col, '') for col in self.standard_columns])
        
        table_info['row_count'] += len(standardized_rows)
        print(f"Added {len(standardized_rows)} rows to table {table_id[:8]}")
    
    def convert_row_to_standard_format(self, row_data: Dict[str, str], table_info: Dict[str, Any], page_num: int) -> Dict[str, str]:
        """Convert extracted row data to standardized format."""
        return {
            'Health_System': table_info['health_system'] or '',
            'Hospital_Name': table_info['hospital_name'] or '',
            'LOB_Type': table_info['lob_type'] or '',
            'Service_Setting': table_info['service_setting'] or '',
            'Section_Type': table_info['carve_out_section'] or 'Regular',
            'Service_Description': row_data.get('service', ''),
            'Billing_Code_Type': row_data.get('code_type', ''),
            'Billing_Codes': row_data.get('codes', ''),
            'Rate_Amount': row_data.get('rate_amount', ''),
            'Rate_Type': row_data.get('rate_type', ''),
            'Additional_Notes': row_data.get('notes', ''),
            'Effective_Date': table_info['effective_date'] or '',
            'Page_Number': str(page_num)
        }
    
    def find_continuation_table(self, extraction_data: HospitalRateData) -> Optional[str]:
        """Find the most likely table for continuation."""
        if not self.active_tables:
            return None
        
        # Find most recent table with matching service setting
        target_setting = extraction_data.service_setting
        
        for table_id in reversed(list(self.active_tables.keys())):
            table_info = self.active_tables[table_id]
            if table_info['service_setting'] == target_setting:
                return table_id
        
        # Fall back to most recent table
        return list(self.active_tables.keys())[-1]
    
    def get_summary(self) -> Dict[str, Any]:
        """Get extraction summary."""
        return {
            'document_metadata': self.document_metadata,
            'tables_created': len(self.active_tables),
            'total_rows': sum(table['row_count'] for table in self.active_tables.values()),
            'csv_files': [table['csv_path'] for table in self.active_tables.values()]
        }

class EnhancedHospitalExtractor:
    """
    Enhanced extractor with improved prompts and error handling.
    """
    
    def __init__(self, client, output_dir: str = None):
        self.client = client
        self.output_dir = Path(output_dir) if output_dir else Path.cwd()
        self.registry = ImprovedTableRegistry(self.output_dir)
    
    def create_detection_prompt(self) -> tuple:
        """Create improved detection prompt with better instructions."""
        base_parser = PydanticOutputParser(pydantic_object=HospitalRateData)
        
        class GeminiLLM:
            def __init__(self, client):
                self.client = client
            
            def __call__(self, prompt: str) -> str:
                try:
                    response = self.client.models.generate_content(
                        model='gemini-2.0-flash',
                        contents=[prompt]
                    )
                    return response.text
                except Exception as e:
                    return f"Error: {e}"
        
        llm_wrapper = GeminiLLM(self.client)
        table_parser = OutputFixingParser.from_llm(parser=base_parser, llm=llm_wrapper)
        
        template = """
You are an expert at extracting hospital rate information from medical documents.

DOCUMENT ANALYSIS INSTRUCTIONS:

1. EXTRACT DOCUMENT METADATA (look at headers, titles, and document top):
   - health_system: Main health system name (e.g., "Mercy Health", "Advocate Health", "Memorial Health System")
   - hospital_names: SPECIFIC hospital facility names (e.g., ["Mercy Springfield Hospital", "Mercy Urbana Hospital"])
     * Look for: "Hospital", "Medical Center", "General Hospital", "Regional Medical Center"
     * IGNORE generic system names - we want specific facility names
   - effective_date: Look for "Effective Date:" followed by a date
   - lob_type: Line of Business type from headers:
     * "COMMERCIAL" → "Commercial"
     * "MEDICARE" → "Medicare" 
     * "MEDICAID" → "Medicaid"
     * "ACOP COMMERCIAL" → "ACOP Commercial"

2. IDENTIFY SERVICE SETTING AND SECTION:
   - service_setting: Look for section headers:
     * Contains "INPATIENT" → "INPATIENT"
     * Contains "OUTPATIENT" → "OUTPATIENT"
   - carve_out_section: Look for section type:
     * Contains "CARVE OUT" → "Carve Out Rates"
     * Otherwise → "Regular Rates"

3. TABLE DETECTION:
   - has_table: true if there's a structured table with Service/Billing Codes/Rates
   - table_type: 
     * "header_with_data" if table has headers and data rows
     * "continuation" if data rows without headers (continuing from previous page)
     * "none" if no table present

4. TABLE DATA EXTRACTION (for each row):
   Extract into table_rows as list of dictionaries with keys:
   - service: Service description (e.g., "Inpatient Psychiatric", "Emergency Care")
   - code_type: Type of billing code (e.g., "DRG Codes", "Revenue Codes", "HCPC Codes")
   - codes: The actual codes (e.g., "880-887", "450, 451, 452, 459")
   - rate_amount: Just the monetary value or percentage (e.g., "$1,800.00", "33%")
   - rate_type: Rate structure (e.g., "Per Diem", "Case Rate", "Percentage of Billed Charges")
   - notes: Additional conditions/notes (e.g., "Paid In Addition to Other Negotiated Rates")

IMPORTANT: 
- For continuation pages, focus on extracting data rows only
- Set is_continuation: true if this appears to be continuing a table from previous page
- Extract hospital names carefully - we want specific facilities, not just system names

{format_instructions}

Analyze this hospital rate document:
"""
        
        prompt = PromptTemplate(
            template=template,
            input_variables=[],
            partial_variables={"format_instructions": table_parser.get_format_instructions()}
        )
        
        return prompt, table_parser
    
    def process_page(self, image_path: str, page_num: int) -> Dict[str, Any]:
        """Process a single page with enhanced error handling."""
        print(f"\nProcessing page {page_num}: {Path(image_path).name}")
        
        try:
            with open(image_path, 'rb') as f:
                image_bytes = f.read()
            
            mime_type = 'image/png' if image_path.lower().endswith('.png') else 'image/jpeg'
            
            # Create and run detection prompt
            detection_prompt, detection_parser = self.create_detection_prompt()
            prompt_text = detection_prompt.format()
            
            response = self.client.models.generate_content(
                model='gemini-2.0-flash',
                contents=[
                    types.Part.from_bytes(data=image_bytes, mime_type=mime_type),
                    prompt_text
                ]
            )
            
            # Parse response
            parsed_data = detection_parser.parse(response.text.strip())
            
            # Print what was detected
            print(f"  Has table: {parsed_data.has_table}")
            if parsed_data.has_table:
                print(f"  Table type: {parsed_data.table_type}")
                print(f"  Service setting: {parsed_data.service_setting}")
                if parsed_data.hospital_names:
                    print(f"  Hospital names: {parsed_data.hospital_names}")
                if parsed_data.table_rows:
                    print(f"  Extracted {len(parsed_data.table_rows)} rows")
            
            # Process based on table type
            if not parsed_data.has_table:
                return {
                    'page_num': page_num,
                    'has_table': False,
                    'extracted_metadata': bool(parsed_data.health_system or parsed_data.hospital_names)
                }
            
            if parsed_data.table_type == "header_with_data":
                # New table with headers and data
                table_id = self.registry.register_new_table(parsed_data, page_num)
                
                if parsed_data.table_rows:
                    self.registry.add_rows_to_table(table_id, parsed_data, page_num)
                
                return {
                    'page_num': page_num,
                    'has_table': True,
                    'table_type': 'new',
                    'table_id': table_id,
                    'rows_added': len(parsed_data.table_rows) if parsed_data.table_rows else 0
                }
            
            elif parsed_data.table_type == "continuation" or parsed_data.is_continuation:
                # Continuation of existing table
                continuation_table_id = self.registry.find_continuation_table(parsed_data)
                
                if continuation_table_id and parsed_data.table_rows:
                    self.registry.add_rows_to_table(continuation_table_id, parsed_data, page_num)
                    
                    return {
                        'page_num': page_num,
                        'has_table': True,
                        'table_type': 'continuation',
                        'table_id': continuation_table_id,
                        'rows_added': len(parsed_data.table_rows)
                    }
                else:
                    print(f"  Warning: Could not find continuation table for page {page_num}")
                    return {
                        'page_num': page_num,
                        'has_table': False,
                        'reason': 'Continuation detected but no matching table found'
                    }
            
        except Exception as e:
            print(f"  Error processing page {page_num}: {str(e)}")
            return {
                'page_num': page_num,
                'has_table': False,
                'error': str(e)
            }
        
        return {
            'page_num': page_num,
            'has_table': False,
            'reason': 'Unknown table type'
        }
    
    def extract_tables_from_pdf(self, pdf_path: str, dpi: int = 300, image_format: str = 'png') -> Dict[str, Any]:
        """
        Extract all tables from PDF with enhanced processing.
        """
        print(f"Starting enhanced table extraction for: {pdf_path}")
        
        # Convert PDF to images
        image_paths = pdf_to_images(pdf_path, self.output_dir, dpi, image_format)
        
        # Process each page
        page_results = []
        
        for page_num, image_path in enumerate(image_paths, 1):
            page_result = self.process_page(image_path, page_num)
            page_results.append(page_result)
        
        # Get final summary
        summary = self.registry.get_summary()
        
        # Compile results
        results = {
            'pdf_path': pdf_path,
            'total_pages': len(image_paths),
            'page_results': page_results,
            'document_metadata': summary['document_metadata'],
            'tables_created': summary['tables_created'],
            'total_rows_extracted': summary['total_rows'],
            'csv_files': summary['csv_files']
        }
        
        # Print final summary
        print(f"\n{'='*60}")
        print(f"EXTRACTION COMPLETE")
        print(f"{'='*60}")
        print(f"Health System: {results['document_metadata']['health_system']}")
        print(f"Hospital Names: {results['document_metadata']['hospital_names']}")
        print(f"LOB Type: {results['document_metadata']['lob_type']}")
        print(f"Effective Date: {results['document_metadata']['effective_date']}")
        print(f"Total Pages: {results['total_pages']}")
        print(f"Tables Created: {results['tables_created']}")
        print(f"Total Rows: {results['total_rows_extracted']}")
        print(f"\nCSV Files:")
        for csv_file in results['csv_files']:
            print(f"  - {csv_file}")
        print(f"{'='*60}")
        
        return results

# Usage example
if __name__ == "__main__":
    # Example usage
    pdf_file = r"C:\Users\N873855\Documents\extracted_tables\Mercy_health.pdf"
    
    from google import genai
    client = genai.Client(vertexai=True, project="anbc-hcb-dev", location="us-central1")
    
    extractor = EnhancedHospitalExtractor(client, output_dir="extracted_tables")
    results = extractor.extract_tables_from_pdf(pdf_file, dpi=300)
    
    print("Enhanced hospital rate extractor ready!")
