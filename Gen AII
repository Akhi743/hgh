import fitz  # PyMuPDF
import os
import csv
import json
import uuid
from pathlib import Path
from typing import List, Optional, Union, Dict, Any
from google.genai import types
import google.genai as genai
from langchain.prompts import PromptTemplate
from langchain.output_parsers import PydanticOutputParser, OutputFixingParser
from pydantic import BaseModel, Field
import pandas as pd

def pdf_to_images(pdf_path, output_dir=None, dpi=150, image_format='png'):
    """Convert each page of a PDF to individual images."""
    pdf_path = Path(pdf_path)
    
    if not pdf_path.exists():
        raise FileNotFoundError(f"PDF file not found: {pdf_path}")
    
    if output_dir is None:
        output_dir = pdf_path.parent
    else:
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
    
    doc = fitz.open(pdf_path)
    image_paths = []
    
    for page_num in range(len(doc)):
        page = doc.load_page(page_num)
        mat = fitz.Matrix(dpi/72, dpi/72)
        pix = page.get_pixmap(matrix=mat)
        
        output_filename = f"{pdf_path.stem}_page_{page_num + 1:03d}.{image_format}"
        output_path = output_dir / output_filename
        
        pix.save(str(output_path))
        image_paths.append(str(output_path))
        
        print(f"Saved page {page_num + 1} to {output_path}")
        if page_num == 20:
            print("Limiting to first 20 pages for large PDFs")
            break
    
    doc.close()
    return image_paths

class TableSection(BaseModel):
    """Model for individual table sections (IP/OP) within a page."""
    section_type: str = Field(description="INPATIENT or OUTPATIENT")
    carve_out: bool = Field(default=False, description="Whether this is a carve out section")
    has_table: bool = Field(description="Whether this section contains table data")
    data: Optional[List[Dict[str, str]]] = Field(default=None, description="Table rows")

class PageAnalysis(BaseModel):
    """Enhanced model for complete page analysis."""
    hospital_name: Optional[str] = Field(default=None, description="Specific hospital facility name")
    effective_date: Optional[str] = Field(default=None, description="Document effective date")
    lob_type: Optional[str] = Field(default=None, description="Line of Business type")
    
    # Multiple sections per page
    sections: List[TableSection] = Field(default=[], description="All table sections found on page")
    
    # Page-level metadata
    has_multiple_sections: bool = Field(default=False, description="Whether page has both IP and OP")
    is_continuation: bool = Field(default=False, description="Whether page continues previous tables")

class DocumentRegistry:
    """Enhanced registry to handle multiple table types per document."""
    
    def __init__(self, output_dir: Path):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # Separate tracking for each table type
        self.inpatient_tables = {}
        self.outpatient_tables = {}
        self.inpatient_carve_tables = {}
        self.outpatient_carve_tables = {}
        
        # Document-level context
        self.document_hospital_name = None
        self.document_effective_date = None
        self.document_lob = None
        
        # Standard columns
        self.standard_columns = [
            'Hospital', 'LOB', 'Place of Service', 'Service Category', 
            'Billing Code Type', 'Billing Code', 'Rate', 'Negotiated Type',
            'Additional Information', 'Effective Date'
        ]
    
    def update_document_context(self, hospital_name: str = None, effective_date: str = None, lob_type: str = None):
        """Update document-level context information."""
        if hospital_name and hospital_name != "N/A":
            # Prioritize specific hospital names over system names
            if (not self.document_hospital_name or 
                self.document_hospital_name == "N/A" or
                ("Hospital" in hospital_name and "Health" not in hospital_name)):
                self.document_hospital_name = hospital_name
        
        if effective_date and effective_date != "N/A":
            self.document_effective_date = effective_date
            
        if lob_type and lob_type != "N/A":
            self.document_lob = lob_type
    
    def get_table_registry(self, service_type: str, is_carve_out: bool = False):
        """Get the appropriate table registry based on service type."""
        if service_type == "INPATIENT":
            return self.inpatient_carve_tables if is_carve_out else self.inpatient_tables
        else:
            return self.outpatient_carve_tables if is_carve_out else self.outpatient_tables
    
    def register_or_update_table(self, section: TableSection, page_num: int) -> str:
        """Register new table or add to existing table."""
        registry = self.get_table_registry(section.section_type, section.carve_out)
        
        # Create table key
        table_key = f"{section.section_type}{'_CARVE' if section.carve_out else ''}"
        
        if table_key not in registry:
            # Create new table
            table_id = str(uuid.uuid4())[:8]
            csv_filename = f"{table_key.lower()}_{table_id}.csv"
            csv_path = self.output_dir / csv_filename
            
            registry[table_key] = {
                'table_id': table_id,
                'csv_path': str(csv_path),
                'start_page': page_num,
                'last_page': page_num,
                'row_count': 0
            }
            
            # Create CSV with headers
            with open(csv_path, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.writer(csvfile)
                writer.writerow(self.standard_columns)
            
            print(f"Created new {table_key} table: {csv_filename}")
        
        # Add data to table
        if section.data:
            self._add_data_to_table(registry[table_key], section, page_num)
        
        return registry[table_key]['csv_path']
    
    def _add_data_to_table(self, table_info: Dict, section: TableSection, page_num: int):
        """Add data rows to table."""
        csv_path = table_info['csv_path']
        standardized_rows = self._convert_to_standard_format(section)
        
        with open(csv_path, 'a', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            for row_data in standardized_rows:
                writer.writerow([row_data.get(col, 'N/A') for col in self.standard_columns])
        
        table_info['last_page'] = page_num
        table_info['row_count'] += len(standardized_rows)
        print(f"Added {len(standardized_rows)} rows to {section.section_type} table")
    
    def _convert_to_standard_format(self, section: TableSection) -> List[Dict[str, str]]:
        """Convert section data to standard CSV format."""
        standardized_rows = []
        
        for row in section.data or []:
            place_of_service = "IP" if section.section_type == "INPATIENT" else "OP"
            
            row_data = {
                'Hospital': self.document_hospital_name or "N/A",
                'LOB': self.document_lob or "N/A",
                'Place of Service': place_of_service,
                'Service Category': row.get('service', 'N/A'),
                'Billing Code Type': row.get('billing_code_type', 'N/A'),
                'Billing Code': row.get('billing_codes', 'N/A'),
                'Rate': row.get('rate_amount', 'N/A'),
                'Negotiated Type': row.get('negotiated_type', 'N/A'),
                'Additional Information': row.get('additional_info', 'N/A'),
                'Effective Date': self.document_effective_date or "N/A"
            }
            standardized_rows.append(row_data)
        
        return standardized_rows
    
    def get_summary(self) -> Dict[str, Any]:
        """Get extraction summary."""
        all_registries = [
            self.inpatient_tables, self.outpatient_tables,
            self.inpatient_carve_tables, self.outpatient_carve_tables
        ]
        
        csv_files = []
        total_rows = 0
        
        for registry in all_registries:
            for table_info in registry.values():
                csv_files.append(table_info['csv_path'])
                total_rows += table_info['row_count']
        
        return {
            'hospital_name': self.document_hospital_name,
            'effective_date': self.document_effective_date,
            'lob_type': self.document_lob,
            'csv_files': csv_files,
            'total_tables': len(csv_files),
            'total_rows': total_rows
        }

class MultiPageTableExtractor:
    """Main extractor class with improved section handling."""
    
    def __init__(self, client, output_dir: str = None):
        self.client = client
        self.output_dir = Path(output_dir) if output_dir else Path.cwd()
        self.registry = DocumentRegistry(self.output_dir)
    
    def create_page_analysis_prompt(self) -> tuple:
        """Create enhanced prompt for complete page analysis."""
        base_parser = PydanticOutputParser(pydantic_object=PageAnalysis)
        
        class GeminiLLM:
            def __init__(self, client):
                self.client = client
            
            def __call__(self, prompt: str) -> str:
                try:
                    response = self.client.models.generate_content(
                        model='gemini-2.0-flash',
                        contents=[prompt]
                    )
                    return response.text
                except Exception as e:
                    return f"Error: {e}"
        
        llm_wrapper = GeminiLLM(self.client)
        parser = OutputFixingParser.from_llm(parser=base_parser, llm=llm_wrapper)
        
        template = """
You are analyzing a hospital rate schedule page that may contain multiple table sections.

DOCUMENT METADATA EXTRACTION:
1. Hospital Name: Extract SPECIFIC facility names, not system names
   - Look for: "Mercy Springfield and Urbana Hospitals", "Advocate Condell Medical Center", "Sistersville General Hospital"
   - AVOID: Generic system names like "Mercy Health", "Advocate Health", "Memorial Health System"

2. Effective Date: Look for "Effective Date:" followed by date

3. Line of Business (LOB): 
   - "COMMERCIAL" → "Commercial"
   - "MEDICARE" → "Medicare" 
   - "MEDICAID" → "Medicaid"
   - "ACOP COMMERCIAL" → "ACOP Commercial"

SECTION IDENTIFICATION:
Look for multiple table sections on the same page:

1. INPATIENT RATES section:
   - Header contains "INPATIENT RATES"
   - May have subsection "INPATIENT CARVE OUT RATES"

2. OUTPATIENT RATES section:
   - Header contains "OUTPATIENT RATES" 
   - May have subsection "OUTPATIENT CARVE OUT RATES"

For EACH section found, extract:
- section_type: "INPATIENT" or "OUTPATIENT"
- carve_out: true if "CARVE OUT" is mentioned
- has_table: true if table data is present
- data: Array of table rows with structure:
  {{
    "service": "Service name/description",
    "billing_code_type": "DRG/Revenue Codes/HCPC Codes/CPT4 Codes",
    "billing_codes": "Actual codes or ranges",
    "rate_amount": "Dollar amount or percentage only",
    "negotiated_type": "Per Diem/Case Rate/Percentage/Base Rate",
    "additional_info": "Special conditions or N/A"
  }}

RATE PARSING EXAMPLES:
- "$1,800.00 Per Diem" → rate_amount="$1,800.00", negotiated_type="Per Diem", additional_info="N/A"
- "33% of Billed Charges" → rate_amount="33%", negotiated_type="Percentage", additional_info="N/A"
- "$750.00 Per Diem Paid In Addition to Other Negotiated Rates" → 
  rate_amount="$750.00", negotiated_type="Per Diem", additional_info="Paid In Addition to Other Negotiated Rates"

IMPORTANT:
- Process ALL table sections on the page
- Set has_multiple_sections=true if both IP and OP sections exist
- Set is_continuation=true if page appears to continue previous tables (no headers, just data)

{format_instructions}

Analyze this page for all hospital rate table sections:
"""
        
        prompt = PromptTemplate(
            template=template,
            input_variables=[],
            partial_variables={"format_instructions": parser.get_format_instructions()}
        )
        
        return prompt, parser
    
    def process_page(self, image_path: str, page_num: int) -> Dict[str, Any]:
        """Process a single page with enhanced section detection."""
        print(f"Processing page {page_num}: {Path(image_path).name}")
        
        try:
            with open(image_path, 'rb') as f:
                image_bytes = f.read()
            
            mime_type = 'image/png' if image_path.lower().endswith('.png') else 'image/jpeg'
            
            # Analyze complete page
            prompt, parser = self.create_page_analysis_prompt()
            prompt_text = prompt.format()
            
            response = self.client.models.generate_content(
                model='gemini-2.0-flash',
                contents=[
                    types.Part.from_bytes(data=image_bytes, mime_type=mime_type),
                    prompt_text
                ]
            )
            
            analysis = parser.parse(response.text.strip())
            
            # Update document context
            self.registry.update_document_context(
                analysis.hospital_name,
                analysis.effective_date,
                analysis.lob_type
            )
            
            # Process each section
            csv_paths = []
            total_rows = 0
            
            for section in analysis.sections:
                if section.has_table and section.data:
                    csv_path = self.registry.register_or_update_table(section, page_num)
                    csv_paths.append(csv_path)
                    total_rows += len(section.data)
            
            result = {
                'page_num': page_num,
                'hospital_name': analysis.hospital_name,
                'sections_found': len(analysis.sections),
                'has_multiple_sections': analysis.has_multiple_sections,
                'csv_paths': csv_paths,
                'total_rows_added': total_rows
            }
            
            if analysis.has_multiple_sections:
                print(f"Page {page_num}: Found multiple sections (IP/OP)")
            
            print(f"Page {page_num}: Added {total_rows} total rows across {len(csv_paths)} tables")
            
            return result
            
        except Exception as e:
            print(f"Error processing page {page_num}: {e}")
            return {
                'page_num': page_num,
                'error': str(e),
                'sections_found': 0,
                'total_rows_added': 0
            }
    
    def extract_tables_from_pdf(self, pdf_path: str, dpi: int = 150, image_format: str = 'png') -> Dict[str, Any]:
        """Extract all tables from PDF with enhanced multi-section support."""
        print(f"Starting enhanced table extraction for: {pdf_path}")
        
        # Convert PDF to images
        image_paths = pdf_to_images(pdf_path, self.output_dir, dpi, image_format)
        
        # Process each page
        results = {
            'pdf_path': pdf_path,
            'total_pages': len(image_paths),
            'processed_pages': [],
            'extraction_summary': {}
        }
        
        for page_num, image_path in enumerate(image_paths, 1):
            page_result = self.process_page(image_path, page_num)
            results['processed_pages'].append(page_result)
        
        # Get final summary
        results['extraction_summary'] = self.registry.get_summary()
        
        # Print summary
        summary = results['extraction_summary']
        print(f"\n=== EXTRACTION SUMMARY ===")
        print(f"Hospital: {summary['hospital_name']}")
        print(f"Effective Date: {summary['effective_date']}")
        print(f"LOB: {summary['lob_type']}")
        print(f"Total pages processed: {results['total_pages']}")
        print(f"Tables created: {summary['total_tables']}")
        print(f"Total rows extracted: {summary['total_rows']}")
        
        if summary['csv_files']:
            print(f"\nCSV Files Created:")
            for csv_file in summary['csv_files']:
                print(f"  - {Path(csv_file).name}")
        
        return results

# Usage example
if __name__ == "__main__":
    pdf_file = r"path_to_your_pdf.pdf"
    
    from google import genai
    client = genai.Client(vertexai=True, project="your-project", location="us-central1")
    
    extractor = MultiPageTableExtractor(client, output_dir="extracted_tables")
    results = extractor.extract_tables_from_pdf(pdf_file, dpi=300)
