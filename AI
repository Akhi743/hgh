import fitz
import csv
import json
import logging
from pathlib import Path
from typing import List, Optional, Dict
from pydantic import BaseModel, Field
from google.genai import types
import google.genai as genai

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# ==========================================
# DATA MODELS
# ==========================================

class ContractRow(BaseModel):
    hospital_name: str = Field(description="Hospital or facility name from the table row")
    charge_master_limit: Optional[str] = Field(description="Charge master limit for this facility")
    charge_master_increase: Optional[str] = Field(description="Charge master increase percentage for this facility")
    effective_date: Optional[str] = Field(description="Effective date for this facility")

class ContractPageExtraction(BaseModel):
    notification_received_date_found: Optional[str] = Field(default=None, description="Notification date if found on this page")
    contract_duration_found: Optional[str] = Field(default=None, description="Contract duration if found on this page")
    contract_rows: List[ContractRow] = Field(description="List of all contract table rows found on this page")

# ==========================================
# STATE MANAGER
# ==========================================

class ContractStateManager:
    def __init__(self):
        self.columns = [
            "Hospital Name", "Charge Master Limit", "Charge Master Increase", 
            "Effective Date", "Contract Duration", "Notification Received Date", "Document Source"
        ]
        self.reset_document_state()
    
    def reset_document_state(self):
        self.notification_received_date = "N/A"
        self.contract_duration = "N/A"
        self.csv_file = None
        self.csv_writer = None
    
    def start_csv(self, output_path: Path):
        self.csv_file = open(output_path, 'w', newline='', encoding='utf-8')
        self.csv_writer = csv.writer(self.csv_file)
        self.csv_writer.writerow(self.columns)
    
    def update_from_page(self, extraction: ContractPageExtraction):
        if extraction.notification_received_date_found and self.notification_received_date == "N/A":
            self.notification_received_date = extraction.notification_received_date_found
            logger.info(f"Stored notification date: '{self.notification_received_date}'")
        
        if extraction.contract_duration_found and self.contract_duration == "N/A":
            self.contract_duration = extraction.contract_duration_found
            logger.info(f"Stored contract duration: '{self.contract_duration}'")
    
    def write_rows(self, extraction: ContractPageExtraction, document_name: str) -> int:
        if not self.csv_writer:
            return 0
        
        rows_written = 0
        for row in extraction.contract_rows:
            csv_row = [
                row.hospital_name,
                row.charge_master_limit or "N/A",
                row.charge_master_increase or "N/A",
                row.effective_date or "N/A",
                self.contract_duration,
                self.notification_received_date,
                document_name
            ]
            self.csv_writer.writerow(csv_row)
            rows_written += 1
        
        if self.csv_file:
            self.csv_file.flush()
        
        return rows_written
    
    def close_csv(self):
        if self.csv_file:
            self.csv_file.close()
            self.csv_file = None
            self.csv_writer = None

# ==========================================
# PDF PROCESSING
# ==========================================

def pdf_to_images(pdf_path: str, output_dir: str, dpi: int = 200) -> List[Path]:
    pdf_path = Path(pdf_path)
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    image_paths = []
    
    doc = fitz.open(str(pdf_path))
    for page_num in range(len(doc)):
        page = doc.load_page(page_num)
        mat = fitz.Matrix(dpi / 72, dpi / 72)
        pix = page.get_pixmap(matrix=mat)
        
        output_path = output_dir / f"{pdf_path.stem}_page_{page_num + 1:03d}.png"
        pix.save(str(output_path))
        image_paths.append(output_path)
    
    doc.close()
    return image_paths

# ==========================================
# CONTRACT EXTRACTOR
# ==========================================

class HealthcareContractExtractor:
    def __init__(self, client, output_dir: str = "contract_extraction"):
        self.client = client
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.state_manager = ContractStateManager()
    
    def get_extraction_prompt(self) -> str:
        json_schema = json.dumps(ContractPageExtraction.model_json_schema(), indent=2)
        
        return f"""
Extract healthcare contract data from this Aetna charge master increase notification.

**DOCUMENT-LEVEL FIELDS:**
1. notification_received_date_found: Date from "We have received your email dated [DATE]"
2. contract_duration_found: Duration from text like "12-month period"

**TABLE EXTRACTION:**
3. contract_rows: Extract EVERY row from facilities table
   - hospital_name: Exact facility name
   - charge_master_limit: Exact limit (e.g., "CP 4.5%/ME 3.0%")
   - charge_master_increase: Exact increase (e.g., "7.0%")
   - effective_date: Effective date if shown

**RULES:**
- Extract each table row separately
- Match data exactly to each facility
- Use null for missing fields

**JSON Schema:**
{json_schema}
"""
    
    def process_page(self, image_path: Path, page_num: int, document_name: str) -> ContractPageExtraction:
        try:
            with open(image_path, 'rb') as f:
                image_bytes = f.read()
            
            mime_type = 'image/png' if image_path.suffix.lower() == '.png' else 'image/jpeg'
            prompt = self.get_extraction_prompt()
            
            # API call with fallback
            try:
                response = self.client.models.generate_content(
                    model='gemini-2.0-flash',
                    contents=[
                        types.Part.from_bytes(data=image_bytes, mime_type=mime_type),
                        prompt
                    ]
                )
            except (AttributeError, TypeError):
                response = self.client.generate_content(
                    contents=[
                        types.Part.from_bytes(data=image_bytes, mime_type=mime_type),
                        prompt
                    ]
                )
            
            # Clean and parse response
            response_text = response.text.strip()
            if response_text.startswith('```json'):
                response_text = response_text.split('```json')[1]
            if response_text.endswith('```'):
                response_text = response_text.rsplit('```', 1)[0]
            response_text = response_text.strip()
            
            extraction = ContractPageExtraction.model_validate_json(response_text)
            
            # Update state and write rows
            self.state_manager.update_from_page(extraction)
            rows_written = self.state_manager.write_rows(extraction, document_name)
            
            if rows_written > 0:
                logger.info(f"Page {page_num}: {rows_written} rows extracted")
            
            return extraction
            
        except Exception as e:
            logger.error(f"Error on page {page_num}: {e}")
            return ContractPageExtraction()
    
    def extract_from_pdf(self, pdf_path: str, dpi: int = 200) -> Dict:
        pdf_path = Path(pdf_path)
        
        # Reset state for new PDF
        self.state_manager.reset_document_state()
        
        # Convert to images
        image_output_dir = self.output_dir / pdf_path.stem / "images"
        image_paths = pdf_to_images(str(pdf_path), str(image_output_dir), dpi)
        
        # Setup CSV
        csv_path = self.output_dir / pdf_path.stem / f"{pdf_path.stem}_contract_data.csv"
        csv_path.parent.mkdir(parents=True, exist_ok=True)
        self.state_manager.start_csv(csv_path)
        
        # Process pages
        total_rows = 0
        for i, image_path in enumerate(image_paths, 1):
            extraction = self.process_page(image_path, i, pdf_path.name)
            total_rows += len(extraction.contract_rows)
        
        self.state_manager.close_csv()
        
        return {
            'pdf_name': pdf_path.name,
            'total_pages': len(image_paths),
            'total_rows': total_rows,
            'csv_path': str(csv_path)
        }

# ==========================================
# CLIENT SETUP
# ==========================================

def create_client():
    return genai.Client(
        vertexai=True, 
        project="anbc-hcb-dev",  # Replace with your project ID
        location="us-central1"   # Replace with your location
    )

# ==========================================
# MAIN FUNCTION
# ==========================================

def extract_healthcare_contract(pdf_path: str, output_dir: str = "contract_extraction") -> Dict:
    client = create_client()
    extractor = HealthcareContractExtractor(client=client, output_dir=output_dir)
    return extractor.extract_from_pdf(pdf_path)

# ==========================================
# USAGE
# ==========================================

if __name__ == "__main__":
    pdf_file = "Aultman Hospital.pdf"  # Replace with your actual PDF path
    
    try:
        results = extract_healthcare_contract(pdf_file)
        
        print("\n" + "="*60)
        print("HEALTHCARE CONTRACT EXTRACTION RESULTS")
        print("="*60)
        print(f"PDF: {results['pdf_name']}")
        print(f"Pages processed: {results['total_pages']}")
        print(f"Total rows: {results['total_rows']}")
        print(f"CSV output: {results['csv_path']}")
        print("="*60)
        
    except Exception as e:
        print(f"Error: {e}")
