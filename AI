import fitz
import os
import csv
import json
import logging
from pathlib import Path
from typing import List, Optional, Dict
from pydantic import BaseModel, Field
from google.genai import types
import google.genai as genai

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('contract_extraction.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# ==========================================
# DATA MODEL
# ==========================================

class ContractExtraction(BaseModel):
    """Healthcare contract data extraction model"""
    hospital_name: Optional[str] = Field(default=None, description="Hospital name or health system name")
    charge_master_limit: Optional[str] = Field(default=None, description="Charge master limit percentage or cap")
    charge_master_increase: Optional[str] = Field(default=None, description="Charge master increase percentage")
    effective_date: Optional[str] = Field(default=None, description="Effective date when changes take effect")
    contract_duration: Optional[str] = Field(default=None, description="Duration or term of the contract")
    notification_received_date: Optional[str] = Field(default=None, description="Date when notification was received/sent")

# ==========================================
# PDF PROCESSING
# ==========================================

def pdf_to_images(pdf_path: str, output_dir: str = None, dpi: int = 200) -> List[Path]:
    """Convert PDF pages to images using PyMuPDF"""
    pdf_path = Path(pdf_path)
    if not pdf_path.exists():
        raise FileNotFoundError(f"PDF file not found: {pdf_path}")
    
    if output_dir is None:
        output_dir = pdf_path.parent / f"{pdf_path.stem}_images"
    else:
        output_dir = Path(output_dir)
    
    output_dir.mkdir(parents=True, exist_ok=True)
    image_paths = []
    
    try:
        doc = fitz.open(str(pdf_path))
        logger.info(f"Converting PDF '{pdf_path.name}' ({len(doc)} pages)")
        
        for page_num in range(len(doc)):
            page = doc.load_page(page_num)
            mat = fitz.Matrix(dpi / 72, dpi / 72)
            pix = page.get_pixmap(matrix=mat)
            
            output_path = output_dir / f"{pdf_path.stem}_page_{page_num + 1:03d}.png"
            pix.save(str(output_path))
            image_paths.append(output_path)
            
        doc.close()
        logger.info(f"Successfully converted {len(image_paths)} pages")
        
    except Exception as e:
        logger.error(f"Failed to convert PDF '{pdf_path.name}': {e}")
        raise
    
    return image_paths

# ==========================================
# EXTRACTOR CLASS
# ==========================================

class HealthcareContractExtractor:
    """Healthcare contract data extractor"""
    
    def __init__(self, client, output_dir: str = "contract_extraction"):
        self.client = client
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # CSV columns
        self.columns = [
            "Hospital Name",
            "Charge Master Limit", 
            "Charge Master Increase",
            "Effective Date",
            "Contract Duration",
            "Notification Received Date",
            "Document Source",
            "Page Number"
        ]
    
    def get_extraction_prompt(self) -> str:
        """Generate extraction prompt for healthcare contracts"""
        json_schema = json.dumps(ContractExtraction.model_json_schema(), indent=2)
        
        return f"""
You are a healthcare contract data extraction specialist. Extract the following information from this document:

**1. Hospital Name**
- **What it is:** Hospital name, health system, medical center, or healthcare organization name
- **Where to look:** Header area, letterhead, facility names, signatures
- **Examples:** "Aultman Hospital", "Fairfield Medical Center", "Mercy Health", "Aetna"
- **Rules:** Extract full official name, remove TIN numbers if present

**2. Charge Master Limit** 
- **What it is:** Charge master limit percentage, rate caps, or charge limitations
- **Where to look:** Contract terms, rate information, tables with percentages
- **Examples:** "CP 4.5%", "ME 3.0%", "charge master limit of 5%", "4.5% ME 3.0%"
- **Rules:** Include exact percentages and context, extract full limit description

**3. Charge Master Increase**
- **What it is:** Charge master increase percentage or rate adjustments
- **Where to look:** Rate adjustment sections, tables, increase notifications
- **Examples:** "7% aggregate increase", "6% increase", "5.0% increase"
- **Rules:** Extract exact percentage with context, look for "increase" terminology

**4. Effective Date**
- **What it is:** Date when the changes, rates, or contract terms take effect
- **Where to look:** Date fields, "effective date" labels, "become effective" text
- **Examples:** "01/01/2025", "1/1/2025", "January 1, 2025", "effective 1/1/2025"
- **Rules:** Look for "effective", "become effective", extract complete date

**5. Contract Duration**
- **What it is:** Duration, term, or validity period of the contract or rates
- **Where to look:** Contract terms, validity periods, time specifications
- **Examples:** "12-month period", "through 2025", "2-year term", "CY2025"
- **Rules:** Extract time periods and duration context

**6. Notification Received Date**
- **What it is:** Date when the notification, letter, or email was received or sent
- **Where to look:** Letter dates, email headers, document dates, "dated" references
- **Examples:** "December 6, 2024", "October 14, 2024", "dated December 6, 2024"
- **Rules:** Look for letter/email dates, notification timing, document timestamps

**EXTRACTION RULES:**
- Extract exact text where possible
- If information is not clearly found, use null
- Look for specific percentages and dates
- Focus on healthcare contract and rate-related information
- Pay attention to tables, formal letter content, and contract terms
- Scan the entire document thoroughly for all fields

**JSON Schema:**
{json_schema}
"""
    
    def process_page(self, image_path: Path, page_num: int, document_name: str) -> ContractExtraction:
        """Process single page and extract contract data"""
        logger.info(f"Processing page {page_num}: {image_path.name}")
        
        try:
            with open(image_path, 'rb') as f:
                image_bytes = f.read()
            
            mime_type = 'image/png' if image_path.suffix.lower() == '.png' else 'image/jpeg'
            prompt = self.get_extraction_prompt()
            
            logger.info("Sending extraction request to Gemini...")
            
            # API call with fallback
            try:
                response = self.client.models.generate_content(
                    model='gemini-2.0-flash',
                    contents=[
                        types.Part.from_bytes(data=image_bytes, mime_type=mime_type),
                        prompt
                    ]
                )
            except (AttributeError, TypeError):
                response = self.client.generate_content(
                    contents=[
                        types.Part.from_bytes(data=image_bytes, mime_type=mime_type),
                        prompt
                    ]
                )
            
            # Clean and parse response
            response_text = response.text.strip()
            if response_text.startswith('```json'):
                response_text = response_text.split('```json')[1]
            if response_text.endswith('```'):
                response_text = response_text.rsplit('```', 1)[0]
            response_text = response_text.strip()
            
            # Parse JSON response
            extraction = ContractExtraction.model_validate_json(response_text)
            
            # Log extracted data
            logger.info(f"Extracted from page {page_num}:")
            logger.info(f"  Hospital Name: {extraction.hospital_name}")
            logger.info(f"  Charge Master Limit: {extraction.charge_master_limit}")
            logger.info(f"  Charge Master Increase: {extraction.charge_master_increase}")
            logger.info(f"  Effective Date: {extraction.effective_date}")
            logger.info(f"  Contract Duration: {extraction.contract_duration}")
            logger.info(f"  Notification Date: {extraction.notification_received_date}")
            
            return extraction
            
        except Exception as e:
            logger.error(f"Error processing page {page_num}: {e}")
            return ContractExtraction()
    
    def extract_from_pdf(self, pdf_path: str, dpi: int = 200) -> Dict:
        """Extract contract data from PDF"""
        pdf_path = Path(pdf_path)
        logger.info(f"Starting healthcare contract extraction: {pdf_path.name}")
        
        try:
            # Convert PDF to images
            image_output_dir = self.output_dir / pdf_path.stem / "images"
            image_paths = pdf_to_images(str(pdf_path), str(image_output_dir), dpi)
            
            # Setup CSV output
            csv_path = self.output_dir / pdf_path.stem / f"{pdf_path.stem}_contract_data.csv"
            csv_path.parent.mkdir(parents=True, exist_ok=True)
            
            # Process all pages and collect extractions
            all_extractions = []
            
            for i, image_path in enumerate(image_paths, 1):
                logger.info(f"\n--- PAGE {i}/{len(image_paths)} ---")
                extraction = self.process_page(image_path, i, pdf_path.name)
                all_extractions.append((extraction, i))
            
            # Write to CSV
            self.write_to_csv(all_extractions, csv_path, pdf_path.name)
            
            # Compile best extraction (consolidate data from all pages)
            consolidated = self.consolidate_extractions(all_extractions)
            
            # Results
            results = {
                'pdf_name': pdf_path.name,
                'total_pages': len(image_paths),
                'csv_path': str(csv_path),
                'consolidated_data': consolidated,
                'all_page_extractions': all_extractions
            }
            
            logger.info(f"\n{'='*60}")
            logger.info(f"EXTRACTION COMPLETE: {pdf_path.name}")
            logger.info(f"{'='*60}")
            logger.info(f"Pages processed: {len(image_paths)}")
            logger.info(f"CSV saved: {csv_path}")
            logger.info(f"Consolidated Results:")
            logger.info(f"  Hospital Name: {consolidated.hospital_name}")
            logger.info(f"  Charge Master Limit: {consolidated.charge_master_limit}")
            logger.info(f"  Charge Master Increase: {consolidated.charge_master_increase}")
            logger.info(f"  Effective Date: {consolidated.effective_date}")
            logger.info(f"  Contract Duration: {consolidated.contract_duration}")
            logger.info(f"  Notification Date: {consolidated.notification_received_date}")
            logger.info(f"{'='*60}")
            
            return results
            
        except Exception as e:
            logger.error(f"Failed to extract {pdf_path.name}: {e}")
            raise
    
    def consolidate_extractions(self, extractions: List) -> ContractExtraction:
        """Consolidate data from all pages to get the best extraction"""
        consolidated = ContractExtraction()
        
        # For each field, pick the best non-null value
        for extraction, page_num in extractions:
            if extraction.hospital_name and not consolidated.hospital_name:
                consolidated.hospital_name = extraction.hospital_name
            if extraction.charge_master_limit and not consolidated.charge_master_limit:
                consolidated.charge_master_limit = extraction.charge_master_limit
            if extraction.charge_master_increase and not consolidated.charge_master_increase:
                consolidated.charge_master_increase = extraction.charge_master_increase
            if extraction.effective_date and not consolidated.effective_date:
                consolidated.effective_date = extraction.effective_date
            if extraction.contract_duration and not consolidated.contract_duration:
                consolidated.contract_duration = extraction.contract_duration
            if extraction.notification_received_date and not consolidated.notification_received_date:
                consolidated.notification_received_date = extraction.notification_received_date
        
        return consolidated
    
    def write_to_csv(self, extractions: List, csv_path: Path, document_name: str):
        """Write extractions to CSV file"""
        with open(csv_path, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(self.columns)
            
            for extraction, page_num in extractions:
                row = [
                    extraction.hospital_name or "N/A",
                    extraction.charge_master_limit or "N/A",
                    extraction.charge_master_increase or "N/A", 
                    extraction.effective_date or "N/A",
                    extraction.contract_duration or "N/A",
                    extraction.notification_received_date or "N/A",
                    document_name,
                    page_num
                ]
                writer.writerow(row)
        
        logger.info(f"CSV written with {len(extractions)} rows")

# ==========================================
# CLIENT SETUP
# ==========================================

def create_client():
    """Create Google Cloud client with Vertex AI"""
    try:
        client = genai.Client(
            vertexai=True, 
            project="anbc-hcb-dev",  # Replace with your project ID
            location="us-central1"   # Replace with your location
        )
        logger.info("Created Vertex AI client successfully")
        return client
    except Exception as e:
        logger.error(f"Failed to create client: {e}")
        raise

# ==========================================
# MAIN FUNCTION
# ==========================================

def extract_healthcare_contract(pdf_path: str, output_dir: str = "contract_extraction") -> Dict:
    """Extract healthcare contract data from single PDF"""
    
    # Create client and extractor
    client = create_client()
    extractor = HealthcareContractExtractor(client=client, output_dir=output_dir)
    
    # Extract data
    results = extractor.extract_from_pdf(pdf_path)
    
    return results

# ==========================================
# USAGE
# ==========================================

if __name__ == "__main__":
    # Your PDF file path
    pdf_file = "your_healthcare_contract.pdf"  # Replace with your actual PDF path
    
    try:
        # Extract contract data
        results = extract_healthcare_contract(pdf_file)
        
        # Print final results
        print("\n" + "="*80)
        print("HEALTHCARE CONTRACT EXTRACTION RESULTS")
        print("="*80)
        print(f"PDF: {results['pdf_name']}")
        print(f"Pages: {results['total_pages']}")
        print(f"Output: {results['csv_path']}")
        print("\nExtracted Data:")
        print("-" * 40)
        
        consolidated = results['consolidated_data']
        print(f"Hospital Name: {consolidated.hospital_name or 'Not Found'}")
        print(f"Charge Master Limit: {consolidated.charge_master_limit or 'Not Found'}")
        print(f"Charge Master Increase: {consolidated.charge_master_increase or 'Not Found'}")
        print(f"Effective Date: {consolidated.effective_date or 'Not Found'}")
        print(f"Contract Duration: {consolidated.contract_duration or 'Not Found'}")
        print(f"Notification Date: {consolidated.notification_received_date or 'Not Found'}")
        
        print("="*80)
        print("Check contract_extraction.log for detailed processing logs")
        
    except Exception as e:
        logger.critical(f"Extraction failed: {e}")
        print(f"Error: {e}")
