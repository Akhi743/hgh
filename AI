import fitz
import csv
import json
import logging
from pathlib import Path
from typing import List, Optional, Dict, Any, Type
from pydantic import BaseModel, Field, create_model
from google.genai import types
import google.genai as genai

# Setup logging
logging.basicConfig(
    level=logging.INFO, 
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('document_extraction.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# ==========================================
# CONFIGURATION SYSTEM
# ==========================================

class ExtractionField(BaseModel):
    """Configuration for a single extraction field"""
    name: str
    description: str
    field_type: str = "Optional[str]"
    examples: List[str] = Field(default_factory=list)
    extraction_rules: List[str] = Field(default_factory=list)

class DocumentTypeConfig(BaseModel):
    """Configuration for a specific document type"""
    document_type: str
    description: str
    
    # Document-level fields (extracted once per document)
    document_fields: List[ExtractionField] = Field(default_factory=list)
    
    # Row-level fields (extracted from tables/repeated structures)
    row_fields: List[ExtractionField] = Field(default_factory=list)
    
    # Detection configuration
    detection_keywords: List[str] = Field(default_factory=list)
    detection_prompt: str = ""
    
    # Extraction instructions
    extraction_instructions: str = ""
    
    # Output configuration
    csv_columns: List[str] = Field(default_factory=list)

# ==========================================
# HEALTHCARE CONTRACT CONFIGURATION
# ==========================================

HEALTHCARE_CONTRACT_CONFIG = DocumentTypeConfig(
    document_type="Healthcare Contract",
    description="Aetna healthcare contract charge master increase notifications",
    
    document_fields=[
        ExtractionField(
            name="notification_received_date",
            description="Date when notification was received",
            examples=["December 6, 2024", "12/6/2024"],
            extraction_rules=["Look for 'We have received your email dated [DATE]'"]
        ),
        ExtractionField(
            name="contract_duration",
            description="Contract duration period",
            examples=["12-month period", "12 months"],
            extraction_rules=["Look for duration text in letter body"]
        )
    ],
    
    row_fields=[
        ExtractionField(
            name="hospital_name",
            description="Hospital or facility name",
            examples=["Aultman Hospital", "Alliance Community Hospital"],
            extraction_rules=["Extract exact facility name from table row"]
        ),
        ExtractionField(
            name="charge_master_limit",
            description="Charge master limit for facility",
            examples=["CP 4.5%/ME 3.0%", "CP 4.5%"],
            extraction_rules=["Extract exact limit from table cell"]
        ),
        ExtractionField(
            name="charge_master_increase",
            description="Charge master increase percentage",
            examples=["7.0%", "6.0%"],
            extraction_rules=["Extract exact increase from table cell"]
        ),
        ExtractionField(
            name="effective_date",
            description="Effective date for facility",
            examples=["01/01/2025", "January 1, 2025"],
            extraction_rules=["Extract effective date if shown in table"]
        )
    ],
    
    detection_keywords=[
        "charge master increase", "aetna", "we have received your email",
        "charge master limit", "network management"
    ],
    
    detection_prompt="""
Is this an Aetna healthcare contract letter about charge master increases? 
Look for: Aetna logo, "charge master increase", "We have received your email/letter", table with facilities.
Answer only: YES or NO
""",
    
    extraction_instructions="Extract ALL healthcare contract data from this Aetna charge master increase letter.",
    
    csv_columns=[
        "Hospital Name", "Charge Master Limit", "Charge Master Increase", 
        "Effective Date", "Contract Duration", "Notification Received Date", "Document Source"
    ]
)

# ==========================================
# DYNAMIC MODEL CREATION
# ==========================================

def create_extraction_models(config: DocumentTypeConfig):
    """Dynamically create Pydantic models based on configuration"""
    
    # Create row model
    row_fields = {}
    for field in config.row_fields:
        if field.field_type == "str":
            row_fields[field.name] = (str, Field(description=field.description))
        else:  # Default to Optional[str]
            row_fields[field.name] = (Optional[str], Field(description=field.description))
    
    RowModel = create_model(f'{config.document_type.replace(" ", "")}Row', **row_fields)
    
    # Create document extraction model
    doc_fields = {}
    for field in config.document_fields:
        doc_fields[field.name] = (Optional[str], Field(default=None, description=field.description))
    
    doc_fields['rows'] = (List[RowModel], Field(default_factory=list, description="Extracted rows"))
    
    DocumentModel = create_model(f'{config.document_type.replace(" ", "")}Extraction', **doc_fields)
    
    return RowModel, DocumentModel

# ==========================================
# CONTRACT EXTRACTOR
# ==========================================

class HealthcareContractExtractor:
    def __init__(self, client, output_dir: str = "contract_extraction"):
        self.client = client
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.state_manager = ContractStateManager()
    
    def get_extraction_prompt(self) -> str:
        json_schema = json.dumps(ContractPageExtraction.model_json_schema(), indent=2)
        
        return f"""
Extract healthcare contract data from this Aetna charge master increase notification.

**DOCUMENT-LEVEL FIELDS:**
1. notification_received_date_found: Date from "We have received your email dated [DATE]"
2. contract_duration_found: Duration from text like "12-month period"

**TABLE EXTRACTION:**
3. contract_rows: Extract EVERY row from facilities table
   - hospital_name: Exact facility name
   - charge_master_limit: Exact limit (e.g., "CP 4.5%/ME 3.0%")
   - charge_master_increase: Exact increase (e.g., "7.0%")
   - effective_date: Effective date if shown

**RULES:**
- Extract each table row separately
- Match data exactly to each facility
- Use null for missing fields

**JSON Schema:**
{json_schema}
"""
    
    def process_page(self, image_path: Path, page_num: int, document_name: str):
        try:
            with open(image_path, 'rb') as f:
                image_bytes = f.read()
            
            mime_type = 'image/png' if image_path.suffix.lower() == '.png' else 'image/jpeg'
            prompt = self.get_extraction_prompt()
            
            # API call for detailed extraction
            try:
                response = self.client.models.generate_content(
                    model='gemini-1.5-flash',
                    contents=[
                        types.Part.from_bytes(data=image_bytes, mime_type=mime_type),
                        prompt
                    ]
                )
            except (AttributeError, TypeError):
                response = self.client.generate_content(
                    contents=[
                        types.Part.from_bytes(data=image_bytes, mime_type=mime_type),
                        prompt
                    ]
                )
            
            # Clean and parse response
            response_text = response.text.strip()
            if response_text.startswith('```json'):
                response_text = response_text.split('```json')[1]
            if response_text.endswith('```'):
                response_text = response_text.rsplit('```', 1)[0]
            response_text = response_text.strip()
            
            extraction = ContractPageExtraction.model_validate_json(response_text)
            
            self.state_manager.update_from_page(extraction)
            rows_written = self.state_manager.write_rows(extraction, document_name, page_num)
            
            if rows_written > 0:
                logger.info(f"Page {page_num}: Successfully extracted {rows_written} rows.")
            
            return extraction
            
        except Exception as e:
            logger.error(f"Error processing page {page_num} for detailed extraction: {e}")
            return ContractPageExtraction(contract_rows=[])

    def _find_letter_pages_with_ai(self, doc: fitz.Document, image_output_dir: Path, dpi: int) -> List[int]:
        """
        Uses a simple AI call to classify each page and find the target letter(s).
        """
        pages_to_process = []
        
        classifier_prompt = """
        Analyze the image of this document page. Is this a formal letter from Aetna Network Management notifying a healthcare provider that 'We have received' their 'notifying us' of a charge master increase?
        
        Answer with only the word 'YES' or 'NO'.
        """
        
        logger.info("Starting AI-powered page search...")
        
        i = 0
        while i < len(doc):
            page_num = i + 1
            page = doc.load_page(i)
            
            # Convert single page to image for the classifier call
            mat = fitz.Matrix(dpi / 72, dpi / 72)
            pix = page.get_pixmap(matrix=mat)
            image_path = image_output_dir / f"{doc.name}_classifier_page_{page_num:03d}.png"
            pix.save(str(image_path))

            try:
                with open(image_path, 'rb') as f:
                    image_bytes = f.read()

                # Make the quick classifier API call
                response = self.client.generate_content(
                    model='gemini-1.5-flash', # Use a fast model for classification
                    contents=[
                        types.Part.from_bytes(data=image_bytes, mime_type='image/png'),
                        classifier_prompt
                    ]
                )
                
                answer = response.text.strip().upper()
                logger.info(f"AI classification for page {page_num}: '{answer}'")
                
                if 'YES' in answer:
                    logger.info(f"AI identified page {page_num} as the target letter.")
                    pages_to_process.append(i)
                    
                    # Check for continuation logic
                    page_text = page.get_text().lower()
                    if "sincerely" not in page_text:
                        if (i + 1) < len(doc):
                            next_page_num = i + 2
                            logger.info(f"'Sincerely' not found on page {page_num}. Adding continuation page {next_page_num}.")
                            pages_to_process.append(i + 1)
                            i += 1 # Skip next page in loop
                
            except Exception as e:
                logger.error(f"Could not classify page {page_num}. Error: {e}")
            
            i += 1
            
        return sorted(list(set(pages_to_process)))

    def extract_from_pdf(self, pdf_path: str, dpi: int = 200) -> Dict:
        pdf_path = Path(pdf_path)
        
        self.state_manager.reset_document_state()
        doc = fitz.open(str(pdf_path))
        
        image_output_dir = self.output_dir / pdf_path.stem / "images"
        image_output_dir.mkdir(parents=True, exist_ok=True)
        
        # 1. Use the AI to find the specific pages to process
        pages_to_process_indices = self._find_letter_pages_with_ai(doc, image_output_dir, dpi)
        
        if not pages_to_process_indices:
            logger.warning(f"AI could not identify any target letter pages in '{pdf_path.name}'.")
            doc.close()
            return {
                'pdf_name': pdf_path.name,
                'total_pages_in_pdf': len(doc),
                'pages_processed': 0,
                'total_rows': 0,
                'csv_path': "N/A"
            }
        
        logger.info(f"AI search complete. Processing pages: {[p+1 for p in pages_to_process_indices]}")
        
        # 2. Setup CSV
        csv_path = self.output_dir / pdf_path.stem / f"{pdf_path.stem}_contract_data.csv"
        self.state_manager.start_csv(csv_path)
        
        # 3. Process only the identified pages for detailed extraction
        total_rows = 0
        for page_index in pages_to_process_indices:
            page_num = page_index + 1
            # Re-use the image saved by the classifier
            image_path = image_output_dir / f"{doc.name}_classifier_page_{page_num:03d}.png"
            
            extraction = self.process_page(image_path, page_num, pdf_path.name)
            if extraction:
                total_rows += len(extraction.contract_rows)
        
        self.state_manager.close_csv()
        doc.close()
        
        return {
            'pdf_name': pdf_path.name,
            'total_pages_in_pdf': len(doc),
            'pages_processed': len(pages_to_process_indices),
            'total_rows': total_rows,
            'csv_path': str(csv_path)
        }

# ==========================================
# CLIENT SETUP
# ==========================================

def create_client():
    """Create Google Cloud client"""
    return genai.Client(
        vertexai=True, 
        project="anbc-hcb-dev",  # Replace with your project ID
        location="us-central1"   # Replace with your location
    )

# ==========================================
# MAIN EXTRACTION FUNCTIONS
# ==========================================

def extract_healthcare_contract(pdf_path: str, output_dir: str = "contract_extraction") -> Dict:
    """Extract healthcare contracts using AI-powered page detection"""
    client = create_client()
    extractor = HealthcareContractExtractor(client=client, output_dir=output_dir)
    return extractor.extract_from_pdf(pdf_path)

# ==========================================
# TESTING FRAMEWORK
# ==========================================

def test_extraction_config(config: DocumentTypeConfig) -> bool:
    """Test that a configuration is valid"""
    try:
        # Test model creation
        RowModel, DocumentModel = create_extraction_models(config)
        
        # Test that required fields exist
        assert config.document_type, "Document type must be specified"
        assert config.csv_columns, "CSV columns must be specified"
        
        # Test that CSV columns match field configuration
        expected_columns = len(config.row_fields) + len(config.document_fields) + 1  # +1 for document source
        actual_columns = len(config.csv_columns)
        assert actual_columns == expected_columns, \
            f"CSV columns ({actual_columns}) must match field count ({expected_columns})"
        
        logger.info(f"Configuration test passed for {config.document_type}")
        return True
        
    except Exception as e:
        logger.error(f"Configuration test failed for {config.document_type}: {e}")
        return False

def run_extraction_tests():
    """Run comprehensive tests on the extraction system"""
    
    # Test healthcare contract configuration
    logger.info("Testing Healthcare Contract configuration")
    success = test_extraction_config(HEALTHCARE_CONTRACT_CONFIG)
    if not success:
        raise ValueError("Healthcare Contract configuration test failed")
    
    logger.info("All extraction tests passed - system is robust and ready")

# ==========================================
# USAGE
# ==========================================

if __name__ == "__main__":
    
    # Run tests first to ensure system integrity
    try:
        run_extraction_tests()
        logger.info("All tests passed - system is ready")
    except Exception as e:
        logger.error(f"Tests failed: {e}")
        exit(1)
    
    # Your original usage (maintained for compatibility)
    pdf_file = "Aultman Hospital.pdf"  # Replace with your actual PDF path
    
    try:
        # Original healthcare contract extraction (unchanged interface)
        results = extract_healthcare_contract(pdf_file)
        
        print("\n" + "="*60)
        print("HEALTHCARE CONTRACT EXTRACTION RESULTS")
        print("="*60)
        print(f"PDF: {results['pdf_name']}")
        print(f"Total Pages in PDF: {results.get('total_pages_in_pdf', 'N/A')}")
        print(f"Pages Processed: {results.get('pages_processed', 'N/A')}")
        print(f"Total Rows Extracted: {results.get('total_rows', 'N/A')}")
        print(f"CSV output: {results.get('csv_path', 'N/A')}")
        print("="*60)
        
    except Exception as e:
        logger.error(f"Extraction failed: {e}")
        print(f"Error: {e}")
