"""
PDF Processing Strategies

Enterprise PDF processing with multiple repair strategies for handling problematic documents.
This module contains the exact PDF handling logic from the working classification system.

The PDF handler provides:
- Multiple PDF opening strategies for corrupted files
- Complexity analysis for enterprise documents
- Safe page access with error recovery
- Form field and encryption detection
"""

import logging
from typing import Optional, List
from dataclasses import dataclass, field

import fitz


logger = logging.getLogger(__name__)


@dataclass
class PDFComplexityInfo:
    """
    Information about PDF complexity and potential processing issues.
    Helps determine the best processing strategy for different document types.
    """
    has_form_fields: bool = False
    has_digital_signatures: bool = False
    has_encryption: bool = False
    has_embedded_files: bool = False
    page_count: int = 0
    complexity_level: str = 'simple'
    potential_issues: List[str] = field(default_factory=list)
    analysis_successful: bool = True


class EnhancedPDFHandler:
    """
    Enterprise PDF handler with multiple repair strategies.
    
    This handler contains the exact PDF processing logic that was validated
    in the working classification system. It provides robust PDF opening
    with multiple fallback strategies for enterprise document processing.
    """
    
    @staticmethod
    def quick_complexity_check(pdf_doc: fitz.Document) -> PDFComplexityInfo:
        """
        Analyze PDF complexity to determine processing strategy.
        
        This analysis helps identify potential issues that might affect
        processing and allows for strategy adjustment based on document type.
        
        Args:
            pdf_doc: PyMuPDF document object
            
        Returns:
            PDFComplexityInfo with analysis results
        """
        complexity_info = PDFComplexityInfo()
        
        try:
            complexity_info.page_count = len(pdf_doc)
            
            # Check for form fields (sample first few pages for performance)
            pages_to_check = min(5, len(pdf_doc))
            for page_num in range(pages_to_check):
                try:
                    page = pdf_doc.load_page(page_num)
                    if page.get_widgets():  # Form fields/widgets detected
                        complexity_info.has_form_fields = True
                        complexity_info.potential_issues.append('form_fields')
                        break
                except Exception:
                    continue
            
            # Check for encryption
            if pdf_doc.needs_pass:
                complexity_info.has_encryption = True
                complexity_info.potential_issues.append('password_protected')
            
            # Check for embedded files
            if pdf_doc.embfile_count() > 0:
                complexity_info.has_embedded_files = True
                complexity_info.potential_issues.append('embedded_files')
            
            # Check metadata for digital signatures
            try:
                metadata = pdf_doc.metadata
                if metadata and any(sig_indicator in str(metadata).lower() 
                                  for sig_indicator in ['signature', 'signed', 'certif']):
                    complexity_info.has_digital_signatures = True
                    complexity_info.potential_issues.append('digital_signatures')
            except Exception:
                pass
            
            # Determine complexity level based on issues found
            issue_count = len(complexity_info.potential_issues)
            if issue_count == 0:
                complexity_info.complexity_level = 'simple'
            elif issue_count <= 2:
                complexity_info.complexity_level = 'moderate'
            else:
                complexity_info.complexity_level = 'complex'
                
        except Exception as e:
            complexity_info.potential_issues.append(f'analysis_error: {str(e)}')
            complexity_info.complexity_level = 'problematic'
            complexity_info.analysis_successful = False
        
        return complexity_info
    
    @staticmethod
    def attempt_pdf_open_with_strategies(pdf_path: str) -> Optional[fitz.Document]:
        """
        Multiple strategies for opening problematic enterprise PDFs.
        
        This method implements the exact PDF opening strategies from the
        working classification system. It tries multiple approaches to
        handle corrupted, encrypted, or otherwise problematic PDF files.
        
        Args:
            pdf_path: Path to the PDF file to open
            
        Returns:
            PyMuPDF Document object or None if all strategies fail
        """
        logger.debug(f"Attempting to open PDF: {pdf_path}")
        
        # Strategy 1: Standard open (fastest approach)
        try:
            doc = fitz.open(pdf_path)
            logger.debug("Standard open successful")
            return doc
        except Exception as e:
            logger.debug(f"Standard open failed: {e}")
        
        # Strategy 2: Open with repair flag
        try:
            doc = fitz.open(pdf_path, filetype="pdf")
            logger.debug("Repair mode open successful")
            return doc
        except Exception as e:
            logger.debug(f"Repair mode open failed: {e}")
        
        # Strategy 3: Memory-based opening (handles file locking issues)
        try:
            with open(pdf_path, 'rb') as f:
                pdf_data = f.read()
            doc = fitz.open(stream=pdf_data, filetype="pdf")
            logger.debug("Memory stream open successful")
            return doc
        except Exception as e:
            logger.debug(f"Memory stream open failed: {e}")
        
        # Strategy 4: Visual content preservation via page reconstruction
        try:
            source_doc = fitz.open(pdf_path)
            clean_doc = fitz.open()
            
            successful_pages = 0
            for page_num in range(min(len(source_doc), 20)):  # Limit for safety
                try:
                    # Copy the entire page including visual content
                    clean_doc.insert_pdf(source_doc, from_page=page_num, to_page=page_num)
                    successful_pages += 1
                except Exception as page_error:
                    logger.debug(f"Skipped page {page_num + 1}: {page_error}")
                    continue
            
            source_doc.close()
            
            if successful_pages > 0:
                logger.debug(f"Page reconstruction successful ({successful_pages} pages)")
                return clean_doc
            else:
                clean_doc.close()
                
        except Exception as e:
            logger.debug(f"Page reconstruction failed: {e}")
        
        logger.warning(f"All repair strategies failed for: {pdf_path}")
        return None
    
    @staticmethod
    def safe_page_access(doc: fitz.Document, page_idx: int) -> Optional[fitz.Page]:
        """
        Safely access a page, handling corruption at the page level.
        
        This method provides safe page access with error handling for
        corrupted or inaccessible pages within otherwise valid PDFs.
        
        Args:
            doc: PyMuPDF document object
            page_idx: Zero-based page index to access
            
        Returns:
            Page object or None if page is inaccessible
        """
        try:
            page = doc.load_page(page_idx)
            # Test if page can be rendered by trying to get its rect
            _ = page.rect
            return page
        except Exception as e:
            logger.debug(f"Page {page_idx + 1} corrupted or inaccessible: {e}")
            return None
    
    @staticmethod
    def get_page_count_safe(pdf_path: str) -> int:
        """
        Safely get the page count of a PDF without fully loading it.
        
        Args:
            pdf_path: Path to the PDF file
            
        Returns:
            Number of pages or 0 if cannot be determined
        """
        try:
            doc = EnhancedPDFHandler.attempt_pdf_open_with_strategies(pdf_path)
            if doc:
                page_count = len(doc)
                doc.close()
                return page_count
            return 0
        except Exception:
            return 0
    
    @staticmethod
    def validate_pdf_structure(pdf_path: str) -> bool:
        """
        Validate basic PDF structure without full processing.
        
        Performs a quick validation to determine if a PDF is worth
        attempting to process or should be marked as corrupted.
        
        Args:
            pdf_path: Path to the PDF file
            
        Returns:
            True if PDF appears to have valid structure
        """
        try:
            doc = EnhancedPDFHandler.attempt_pdf_open_with_strategies(pdf_path)
            if not doc:
                return False
            
            # Basic structure validation
            has_pages = len(doc) > 0
            can_access_first_page = False
            
            if has_pages:
                first_page = EnhancedPDFHandler.safe_page_access(doc, 0)
                can_access_first_page = first_page is not None
            
            doc.close()
            return has_pages and can_access_first_page
            
        except Exception:
            return False
    
    @staticmethod
    def extract_basic_metadata(pdf_path: str) -> dict:
        """
        Extract basic metadata from a PDF file safely.
        
        Args:
            pdf_path: Path to the PDF file
            
        Returns:
            Dictionary with basic metadata or empty dict if extraction fails
        """
        metadata = {
            'page_count': 0,
            'file_size': 0,
            'has_text': False,
            'creation_date': None,
            'modification_date': None,
            'accessibility_score': 0.0
        }
        
        try:
            import os
            
            # Get file size
            metadata['file_size'] = os.path.getsize(pdf_path)
            
            # Try to open and analyze PDF
            doc = EnhancedPDFHandler.attempt_pdf_open_with_strategies(pdf_path)
            if not doc:
                return metadata
            
            metadata['page_count'] = len(doc)
            
            # Check for text content on first few pages
            pages_to_check = min(3, len(doc))
            text_found = False
            accessible_pages = 0
            
            for page_idx in range(pages_to_check):
                page = EnhancedPDFHandler.safe_page_access(doc, page_idx)
                if page:
                    accessible_pages += 1
                    try:
                        text = page.get_text()
                        if text.strip():
                            text_found = True
                    except:
                        pass
            
            metadata['has_text'] = text_found
            metadata['accessibility_score'] = accessible_pages / max(pages_to_check, 1)
            
            # Try to get document metadata
            try:
                doc_metadata = doc.metadata
                if doc_metadata:
                    metadata['creation_date'] = doc_metadata.get('creationDate')
                    metadata['modification_date'] = doc_metadata.get('modDate')
            except:
                pass
            
            doc.close()
            
        except Exception as e:
            logger.debug(f"Failed to extract metadata from {pdf_path}: {e}")
        
        return metadata
